

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapter 3: Basic Architecture &mdash; Software-Defined Networks: A Systems Approach Version 0.3-dev documentation</title>
  

  
  
    <link rel="shortcut icon" href="static/bridge.ico"/>
  
  
  

  
  <script type="text/javascript" src="static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
        <script type="text/javascript" src="static/jquery.js"></script>
        <script type="text/javascript" src="static/underscore.js"></script>
        <script type="text/javascript" src="static/doctools.js"></script>
        <script type="text/javascript" src="static/language_data.js"></script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Chapter 4: White-Box Switches" href="switch.html" />
    <link rel="prev" title="Chapter 2: Use Cases" href="uses.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Software-Defined Networks: A Systems Approach
          

          
          </a>

          
            
            
              <div class="version">
                Version 0.3-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Chapter 1:  Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="uses.html">Chapter 2:  Use Cases</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chapter 3:  Basic Architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#software-stack">3.1 Software Stack</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#switch-vs-host-implementation">3.1.1 Switch vs Host Implementation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#white-box-switch">3.2 White-Box Switch</a></li>
<li class="toctree-l2"><a class="reference internal" href="#switch-os">3.3 Switch OS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#network-os">3.4 Network OS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#leaf-spine-fabric">3.5 Leaf-Spine Fabric</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="switch.html">Chapter 4:  White-Box Switches</a></li>
<li class="toctree-l1"><a class="reference internal" href="stratum.html">Chapter 5:  Switch OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="onos.html">Chapter 6:  Network OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="trellis.html">Chapter 7:  Leaf-Spine Fabric</a></li>
<li class="toctree-l1"><a class="reference internal" href="future.html">Chapter 8:  Future of SDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">Hands-on Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html">About The Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">About The Authors</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Software-Defined Networks: A Systems Approach</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Chapter 3:  Basic Architecture</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/arch.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="switch.html" class="btn btn-neutral float-right" title="Chapter 4: White-Box Switches" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="uses.html" class="btn btn-neutral float-left" title="Chapter 2: Use Cases" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="chapter-3-basic-architecture">
<h1>Chapter 3:  Basic Architecture<a class="headerlink" href="#chapter-3-basic-architecture" title="Permalink to this headline">¶</a></h1>
<p>SDN is an approach to building networks that favors programmable
commodity hardware, with the intelligence that forwards packets—as
well as controls packet forwarding—implemented in software. Realizing
such a design is independent of any particular protocol stack, but
instead requires a set of open APIs and a new collection of software
components that support those APIs. This chapter introduces the basic
architecture of such an <em>SDN software stack</em>.</p>
<p>This chapter defines the general architecture of such a software
stack, and while there are multiple options for the specific
components and tools that can be plugged into this architecture, it
also introduces an example set. We do this to make the discussion more
concrete, but the particular components we describe have two important
attributes. One, they are open source and freely available on GitHub.
Two, they are designed to work together, providing a comprehensive
solution; there are no gaps in our story. Both attributes make it
possible for <em>anyone</em> to build the same end-to-end system that is
running today in production networks.</p>
<div class="section" id="software-stack">
<h2>3.1 Software Stack<a class="headerlink" href="#software-stack" title="Permalink to this headline">¶</a></h2>
<p>An overview of the software stack is given in <a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure 12</span></a>, which includes a <em>White-Box Switch</em> running a local
<em>Switch OS</em>, controlled by a global Network OS hosting a collection of
<em>Control Applications</em>. <a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure 12</span></a> also calls out
a corresponding set of exemplar open source components (<em>Trellis</em>,
<em>ONOS</em>, and <em>Stratum</em>) on the right, as well as a related <em>P4
Toolchain</em> on the left.<a class="footnote-reference" href="#id2" id="id1">[1]</a> This chapter introduces these components, with
later chapters giving more detail.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>We sometimes call this the <strong>TOST</strong> stack: <strong>T</strong>rellis running
on <strong>O</strong>NOS running on <strong>S</strong>tratum running on <strong>T</strong>ofino.</td></tr>
</tbody>
</table>
<p>Note the similarity between this diagram and <a class="reference internal" href="intro.html#fig-market2"><span class="std std-numref">Figure 2</span></a> in Chapter 1, both of which include two open
interfaces: one between the Control Apps and the Network OS, and a
second between the Network OS and the underlying white-box
switches. These two interfaces are depicted as “API shims” in
<a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure 12</span></a>, and in the context of the exemplar
components, correspond to a combination of <em>gNMI</em>, <em>gNOI</em> and
<em>FlowObjective</em> in the first case, and a combination of <em>gNMI</em>, <em>gNOI</em>
and either <em>P4Runtime</em> or <em>OpenFlow</em> in the second case. That gRPC is
shown as the transport protocol for these two APIs is an
implementation choice, but one that we will take for granted from here
on.</p>
<div class="figure align-center" id="id5">
<span id="fig-stack"></span><a class="reference internal image-reference" href="_images/Slide8.png"><img alt="_images/Slide8.png" src="_images/Slide8.png" style="width: 550px;" /></a>
<p class="caption"><span class="caption-number">Figure 12. </span><span class="caption-text">Overall architecture of the SDN software stack.</span></p>
</div>
<p>It is important to keep in mind that the software components listed in
<a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure 12</span></a> correspond to active open source
projects, and as a consequence, they continue to evolve (as do their
APIs). Specific versions of each component—and their associated
APIs—have been integrated and deployed into both trial and production
environments. For example, while the figure shows P4Runtime as a
candidate control interface exported by the Switch OS, there are
deployed solutions that use OpenFlow instead. (This includes the
Comcast deployment.) Similarly, while the figure shows gNMI/gNOI as
the config/ops interface to each switch, there are solutions that use
NETCONF instead.</p>
<p>For the purpose of this book, we do not attempt to track all possible
combinations of component versions and APIs, but opt instead to focus
on the single consistent stack enumerated in <a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure 12</span></a>, since it represents our best judgement as to the “right”
approach based on experience (so far) with earlier versions up-and-down
the stack.</p>
<div class="section" id="switch-vs-host-implementation">
<h3>3.1.1 Switch vs Host Implementation<a class="headerlink" href="#switch-vs-host-implementation" title="Permalink to this headline">¶</a></h3>
<p>The top-to-bottom view of the software stack shown in <a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure
12</span></a> is from the perspective of a single switch, but it is
important to also keep the network perspective in
mind. <a class="reference internal" href="#fig-e2e"><span class="std std-numref">Figure 13</span></a> gives such a perspective by
focusing on an end-to-end path through the network, connecting
Virtual Machines (VMs).</p>
<div class="figure align-center" id="id6">
<span id="fig-e2e"></span><a class="reference internal image-reference" href="_images/Slide19.png"><img alt="_images/Slide19.png" src="_images/Slide19.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Figure 13. </span><span class="caption-text">End-to-End Perspective of a Software-Defined Network, including
the end hosts and the Virtual Machines (VMs) they host.</span></p>
</div>
<p>This perspective highlights two important aspects of the system. The
first re-enforces the point we’ve been making: that the Network OS
(e.g., ONOS) is network-wide, while the Switch OS (e.g., Stratum) is
per-switch.</p>
<p>The second is that part of the SDN software stack runs on the end
hosts. In particular, there is a <em>Virtual Switch (vSwitch)</em>—typically
implemented in software as part of the Virtual Machine Hypervisor
running on the server—that is responsible for forwarding packets to
and from the VMs running on that server. Just like a physical switch,
the vSwitch forwards packets from input port to output port, but these
are virtual ports connected to VMs rather than physical ports
connected to physical machines.</p>
<p>Fortunately, we can view a vSwitch as behaving just like a physical
switch, including the APIs it supports. That a vSwitch is implemented
in software on a general-purpose processor rather than in an ASIC is
an implementation detail. While this is a true statement, being a
software switch dramatically lowers the barrier to introducing
additional features, so the feature set is both richer and more
dynamic. For example, <em>Open vSwitch (OvS)</em> is a widely-used open
source vSwitch that has been integrated with an assortment of
complementary tools. One example is DPDK, another open source
component that optimizes the path from network device to/from
processes running in user space on the host OS. Although it’s an
important topic, this book does not explore the full range of
possibilities for a vSwitch like OvS or other end-host optimizations,
but instead treats it just like any other switch along the end-to-end
path.</p>
<p>Another implementation detail shown in <a class="reference internal" href="#fig-e2e"><span class="std std-numref">Figure 13</span></a>
is that the host may have a <em>Smart Network Interface Card (SmartNIC)</em>
that assists (or possibly even replaces) the vSwitch. Vendors have a
long history of off-loading kernel functionality onto NICs (e.g.,
everything from computing TCP/IP checksums to supporting VMs), but in
the SDN context, the interesting possibility is to replicate the
forwarding pipeline found on the network switches. Again, there are a
range of possible implementation choices, including both FPGA and
ASIC, as well as whether the NIC is fixed-function or programmable
(using P4). For our purposes, we will treat such Smart NICs as yet
another switching element along the end-to-end path.</p>
<div class="sidebar">
<p class="first sidebar-title">Host-Centric Perspective</p>
<p>This book adopts a network-oriented perspective of SDN, one
that treats the end-host (both the virtual switch running in
the host OS and the NIC connecting the host to the network) as
an extension of the network, running under the control of a
Network OS. A more host-centric perspective is equally valid,
and perhaps more importantly, comes with a robust ecosystem of
open source software that runs as part of the host OS.</p>
<p class="last">DPDK is one example. Another example that’s gaining traction
is the combination of eBPF (extended Berkeley Packet Filter)
and XDP (eXpress Data Path). When used together, they provide
a way to program generalized Match-Action rules in the OS
kernel, or potentially even on a SmartNIC.  This is similar in
spirit to OpenFlow and P4, except they allow for the Action
part to be an arbitrary program. In contrast, OpenFlow defines
a fixed set of Actions, and P4 is a restricted language for
expressing Actions (e.g., it does not include loops). This is
necessary when the Action must execute within a fixed cycle
budget, as is the case for a switch-based forwarding pipeline.</p>
</div>
</div>
</div>
<div class="section" id="white-box-switch">
<h2>3.2 White-Box Switch<a class="headerlink" href="#white-box-switch" title="Permalink to this headline">¶</a></h2>
<p>Starting at the bottom and working our way up the stack shown in
<a class="reference internal" href="#fig-stack"><span class="std std-numref">Figures 12</span></a> and <a class="reference internal" href="#fig-e2e"><span class="std std-numref">13</span></a>, the
network data plane is implemented by an interconnected set of
white-box switches. Our focus for now is on a single switch, where the
overall network topology is dictated by the Control Applications
running at the top of the software stack. For example, we describe a
Control Application that manages a leaf-spine topology in a later
section.</p>
<p>The architecture is agnostic as to the switch vendor, but the full
software stack outlined in this chapter runs on switches built using
Tofino and Tomahawk switching chips manufactured by Barefoot Networks
(now an Intel company) and Broadcom, respectively. The Tofino chip
implements a programmable forwarding pipeline based on PISA, while the
Tomahawk chip implements a fixed-function pipeline.</p>
<p>In the case of both chips, a pair of P4 programs defines the
forwarding pipeline. The first (<code class="docutils literal notranslate"><span class="pre">forward.p4</span></code>) specifies the
forwarding behavior. The second (<code class="docutils literal notranslate"><span class="pre">arch.p4</span></code>) specifies the logical
architecture of the target forwarding chip. The P4 compiler
generates target files that are loaded into both the Network OS and
the switch. These target files are not named in <a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure 12</span></a> (we will return to the details in Chapters 4 and 5), but
both components need to know about the output because one <em>implements</em>
the forwarding behavior (the switch), and the other <em>controls</em> the
forwarding behavior (the Network OS).</p>
<p>We return to the details of the compiler toolchain in Chapter 4, which
includes answering the question of why we need a P4 program in the
case of a fixed-function switching chip. To preview that discussion,
P4 programs are written to an abstract model of the forwarding
pipeline, and whether the chip’s actual hardware pipeline is fixed or
programmable, we still need to know how to map the abstract pipeline
onto the physical pipeline. This is where <code class="docutils literal notranslate"><span class="pre">arch.p4</span></code> plays a role. As
for the role of <code class="docutils literal notranslate"><span class="pre">forward.p4</span></code>, this program actually <em>prescribes</em> the
pipeline in the case of a programmable chip, whereas for the
fixed-function chip, <code class="docutils literal notranslate"><span class="pre">forward.p4</span></code> merely <em>describes</em> the
pipeline. But we still need <code class="docutils literal notranslate"><span class="pre">forward.p4</span></code> in both cases because the
toolchain uses it to generate the API that sits between the control
and data planes.</p>
</div>
<div class="section" id="switch-os">
<h2>3.3 Switch OS<a class="headerlink" href="#switch-os" title="Permalink to this headline">¶</a></h2>
<p>Moving up from the base hardware, each switch runs a local Switch
OS. Not to be confused with the Network OS that manages a network of
switches, this Switch OS runs on a commodity processor internal to
the switch (not shown in <a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure 12</span></a>). It is
responsible for handling API calls issued to the switch, for example
from the Network OS. This includes taking the appropriate action on
the switch’s internal resources, which sometimes affects the switching
chip.</p>
<p>Multiple open source Switch OSes are available (including SONiC,
originally developed at Microsoft Azure), but we use a combination of
Stratum and <em>Open Network Linux (ONL)</em> as our primary example. ONL is
a switch-ready distribution of Linux (originally prepared by
BigSwitch), while Stratum (originally developed at Google) is
primarily responsible for translating between the external-facing API
and the internal switch resources. For this reason, we sometimes refer
to Stratum as a <em>Thin Switch OS</em>.</p>
<p>Stratum mediates all interactions between the switch and the outside
world. This includes loading the target files generated by the P4
compiler, which defines a contract between the data plane and the
control plane. This contract effectively replaces OpenFlow’s flow rule
abstraction with an auto-generated specification. The rest of the
Stratum-managed API is defined as follows:</p>
<ul class="simple">
<li><strong>P4Runtime:</strong> An interface for controlling forwarding behavior at
runtime. It is the key for populating forwarding tables and
manipulating forwarding state, and it does so in a P4 program and
hardware agnostic way. (For completeness, <a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure 12</span></a> also lists OpenFlow as an alternative control interface.)</li>
<li><strong>gNMI (gRPC Network Management Interface):</strong> Used to set and
retrieve configuration state. gNMI is usually paired with OpenConfig
YANG models that define the structure of the configuration and state
tree.</li>
<li><strong>gNOI (gRPC Network Operations Interfaces):</strong> Used to set and
retrieve operational state, for example supporting certificates
management, device testing, software upgrades, and networking
troubleshooting.</li>
</ul>
<p>If you recall the distinction between Control and Configuration
introduced in Chapter 1, then you will recognize P4Runtime as the
Control API and the gNMI/gNOI combination as a modern version of a
switch’s traditional Configuration API. This latter API has
historically been called the OAM interface (for “Operations,
Administration, and Maintenance”), and it has most often been
implemented as a command-line interface.</p>
</div>
<div class="section" id="network-os">
<h2>3.4 Network OS<a class="headerlink" href="#network-os" title="Permalink to this headline">¶</a></h2>
<p>The Network OS is a platform for configuring and controlling a network
of white-box switches. It runs off-switch as a logically centralized
SDN controller, and manages a set of switches on a network-wide
basis. Central to this role is responsibility for monitoring the state
of those switches (e.g., detecting port and link failures),
maintaining a global view of the topology that reflects the current
state of the network, and making that view available to any interested
Control Apps. Those Control Apps, in turn, “instruct” the Network OS
to control packet flows through the underlying switches according to
whatever service they are providing. The way these “control
instructions” are expressed is a key aspect of the Network OS’s API.</p>
<p>Going beyond this conceptual description requires a specific Network
OS, and we use <em>ONOS (Open Network Operating System)</em> as our
exemplar. ONOS is best-of-breed in terms of performance, scalability,
and availability. At a high-level, ONOS takes responsibility for three
things:</p>
<ul class="simple">
<li><strong>Managing Topology:</strong> Tracks inventory of network infrastructure
devices and their interconnection to provide a shared view of the
network environment for the rest of the platform and applications.</li>
<li><strong>Managing Configuration:</strong> Facilitates issuing, tracking, rolling
back, and validating atomic configuration operations on multiple
network devices. This effectively mirrors the per-switch
configuration and operation interfaces (also using gNMI and gNOI),
but does so at the network level rather than the device level.</li>
<li><strong>Controlling Switches:</strong> Allows shaping the data plane packet
processing pipelines of the network switches and subsequent control
of flow rules, group, meters and other building blocks within those
pipelines.</li>
</ul>
<p>With respect to this last role, ONOS exports a northbound
<em>FlowObjectives</em> abstraction, which generalizes Flow Rules in a
pipeline-independent way.<a class="footnote-reference" href="#id4" id="id3">[2]</a> This interface, which Chapter 6
describes in more detail, is not standardized in the same way as the
control interface exported by individual switches. As with a
conventional OS running on a server, applications written to the ONOS
API do not easily port to another Network OS. The requirement is that
this interface be open and well-defined; not that there be just one
such interface. If over time there is consensus about the Network OS
interface, then applications will be more easily portable. But just as
with server operating systems, the higher one goes up the software
stack, the more difficult it becomes to reach such a consensus.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>We make no claim that FlowObjectives are an ideal interface for
controlling a switch. They evolved out of necessity, allowing
developers to deal with different pipelines. Defining a general
interface is the subject of ongoing research.</td></tr>
</tbody>
</table>
<p>Finally, although <a class="reference internal" href="#fig-stack"><span class="std std-numref">Figure 12</span></a> does not show any
details about the internals of ONOS, to better appreciate the role it
plays in the larger scheme of things, we note that the most critical
subsystem in any Network OS is a <em>Scalable Key/Value Store</em>. Because
ONOS provides a logically centralized view of the network, the key to
its performance, scalability, and availability is how it stores that
state. In the case of ONOS, this store is provided by a companion open
source project, called Atomix, which implements the RAFT consensus
algorithm. Storage services like Atomix are the cornerstone of nearly
all horizontally scalable cloud services today, as Chapter 6 describes
in more detail.</p>
</div>
<div class="section" id="leaf-spine-fabric">
<h2>3.5 Leaf-Spine Fabric<a class="headerlink" href="#leaf-spine-fabric" title="Permalink to this headline">¶</a></h2>
<p>Because we use ONOS as the Network OS, we are limited to ONOS-hosted
SDN Control Applications. For illustrative purposes, we use Trellis as
that Control App. Trellis implements a <em>leaf-spine</em> fabric on a
network of white-box switches. This means Trellis dictates a
particular network topology: a leaf-spine topology common to
datacenter clusters. As outlined in Section 2.3, this topology
includes a set of leaf switches, each of which serves as a Top-of-Rack
switch (i.e., it connects all the servers in a single rack), where the
leaf switches are, in turn, interconnected by a set of spine switches.</p>
<p>At a high level, Trellis plays three roles. First, it provides a
switching fabric that interconnects servers—and the VMs running on
those servers—in a multi-rack cluster. Second, it connects the cluster
as a whole upstream to peer networks, including the Internet, using
BGP (i.e., it behaves much like a router). Third, it connects the
cluster as a whole to downstream access networks (i.e., it terminates
access network technologies like PON and LTE/5G). In other words,
instead of thinking about Trellis as a conventional leaf-spine fabric
that’s locked away in some datacenter, Trellis is best viewed an
interconnect running at the network edge, helping to bridge
access-specific edge clouds to IP-based datacenter clouds.</p>
<p>In terms of implementation, Trellis actually corresponds to a suite of
Control Apps running on ONOS, as opposed to a single app. This suite
supports several control plane features, including:</p>
<ul class="simple">
<li>VLANs and L2 bridging</li>
<li>IPv4 and IPv6 unicast and multicast routing</li>
<li>DHCP L3 relay</li>
<li>Dual-homing of servers and upstream routers</li>
<li>QinQ forwarding/termination</li>
<li>MPLS-based pseudowires.</li>
</ul>
<p>For each of these features, the corresponding Control App interacts
with ONOS—by observing changes in the network topology and issuing
Flow Objectives—rather than by using any of the standard protocol
implementations found in legacy routers and switches. The only time a
legacy protocol is involved is when Trellis needs to communicate with
the outside world (e.g., upstream metro/core routers), in which case
it uses standard BGP (as implemented by the open source Quagga
server).</p>
<div class="figure align-center" id="id7">
<span id="fig-trellis"></span><a class="reference internal image-reference" href="_images/Slide9.png"><img alt="_images/Slide9.png" src="_images/Slide9.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Figure 14. </span><span class="caption-text">Trellis suite of control apps managing a (potentially distributed)
leaf-spine fabric.</span></p>
</div>
<p>Finally, Trellis is sometimes deployed at a single site with multiple
mobile base stations connected via Trellis leaf-switches. But Trellis
can also be extended to multiple sites deeper into the network using
multiple stages of spines, as shown in <a class="reference internal" href="#fig-trellis"><span class="std std-numref">Figure 14</span></a>. Chapter 7 describes all of this in more detail.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="switch.html" class="btn btn-neutral float-right" title="Chapter 4: White-Box Switches" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="uses.html" class="btn btn-neutral float-left" title="Chapter 2: Use Cases" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
