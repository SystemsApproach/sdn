

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapter 5: Switch OS &mdash; Software-Defined Networks: A Systems Approach Version 0.3-dev documentation</title>
  

  
  
    <link rel="shortcut icon" href="static/bridge.ico"/>
  
  
  

  
  <script type="text/javascript" src="static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
        <script type="text/javascript" src="static/jquery.js"></script>
        <script type="text/javascript" src="static/underscore.js"></script>
        <script type="text/javascript" src="static/doctools.js"></script>
        <script type="text/javascript" src="static/language_data.js"></script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Chapter 6: Network OS" href="onos.html" />
    <link rel="prev" title="Chapter 4: White-Box Switches" href="switch.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Software-Defined Networks: A Systems Approach
          

          
          </a>

          
            
            
              <div class="version">
                Version 0.3-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Chapter 1:  Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="uses.html">Chapter 2:  Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="arch.html">Chapter 3:  Basic Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="switch.html">Chapter 4:  White-Box Switches</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chapter 5:  Switch OS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#thin-switch-os">5.1 Thin Switch OS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#p4runtime">5.2 P4Runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gnmi-and-gnoi">5.3 gNMI and gNOI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sonic">5.4 SONiC</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="onos.html">Chapter 6:  Network OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="trellis.html">Chapter 7:  Leaf-Spine Fabric</a></li>
<li class="toctree-l1"><a class="reference internal" href="future.html">Chapter 8:  Future of SDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">Hands-on Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html">About The Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">About The Authors</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Software-Defined Networks: A Systems Approach</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Chapter 5:  Switch OS</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/stratum.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="onos.html" class="btn btn-neutral float-right" title="Chapter 6: Network OS" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="switch.html" class="btn btn-neutral float-left" title="Chapter 4: White-Box Switches" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="chapter-5-switch-os">
<h1>Chapter 5:  Switch OS<a class="headerlink" href="#chapter-5-switch-os" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the operating system running on every white-box
switch, where equating a bare-metal switch with a bare-metal server is
a good mental model: It has a general-purpose processor running a
Linux-based OS, plus a “packet forwarding accelerator” similar in
spirit to a GPU.</p>
<p>The most common foundation for this Switch OS is <em>Open Network Linux
(ONL)</em>, an open source project of the Open Compute Project. ONL starts
with the Debian distribution of Linux, and augments it with support
for hardware that is unique to switches, including the <em>Small
Form-factor Pluggable (SFP)</em> interface module shown in <a class="reference internal" href="switch.html#fig-switch"><span class="std std-numref">Figure
15</span></a>.</p>
<p>This chapter does not go into these low-level device driver details,
but instead focuses on the <em>Northbound Interface (NBI)</em> exported by
the Switch OS to the control plane, whether that control plane runs
on-switch (as a program running in user space on top of the Switch OS)
or off-switch (as an SDN controller like ONOS). And as introduced in
Chapter 3, we will use Stratum as our concrete example of the layer of
software that implements this NBI on top of ONL. Stratum is sometimes
called a <em>Thin Switch OS</em>, where the operative word is “thin” because
it essentially implements an API shim. What’s interesting about the
shim is the set of APIs it supports, and correspondingly, the vast
majority of this chapter focuses on those APIs.</p>
<div class="section" id="thin-switch-os">
<h2>5.1 Thin Switch OS<a class="headerlink" href="#thin-switch-os" title="Permalink to this headline">¶</a></h2>
<p>This section describes the set of components that implement an
SDN-ready Northbound Interface for the Switch OS running on a
white-box switch. The details are drawn from Stratum, an open source
project at the ONF that started with production-quality code made
available by Google. <a class="reference internal" href="#fig-stratum"><span class="std std-numref">Figure 24</span></a> gives a
high-level overview of Stratum, and to re-emphasize, it’s the exposed
interfaces—P4Runtime, gNMI, and gNOI—that are the important take-aways
of this chapter. We show these few implementation details in this
section only as a way of grounding the description of an end-to-end
workflow for developers implementing SDN-based solutions.</p>
<div class="figure align-center" id="id3">
<span id="fig-stratum"></span><a class="reference internal image-reference" href="_images/Slide17.png"><img alt="_images/Slide17.png" src="_images/Slide17.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Figure 24. </span><span class="caption-text">High-level schematic of Stratum, a Thin Switch OS running on top
of Open Networking Linux.</span></p>
</div>
<p>Stratum exports three primary Northbound Interfaces: (1) P4Runtime is
used to control the switch’s forwarding behavior; (2) gNMI is used to
configure the switch; and (3) gNOI is used to access other operational
variables on the switch. All three interfaces are gRPC services (not
shown), which implies there is a corresponding set of <em>Protocol
Buffers (protobufs)</em> that specify the API methods and supported
parameters of each. A tutorial on gRPC and protobufs is beyond the
scope of this book, but a brief introduction to both can be found
online.</p>
<div class="admonition-further-reading admonition" id="reading-grpc">
<p class="first admonition-title">Further Reading</p>
<p><a class="reference external" href="https://book.systemsapproach.org/ee/rpc.html#grpc">gRPC</a>.
<em>Computer Networks: A Systems Approach</em>, 2020.</p>
<p class="last"><a class="reference external" href="https://book.systemsapproach.org/e2e/presentation.html#protobufs">Protocol Buffers</a>.
<em>Computer Networks: A Systems Approach</em>, 2020.</p>
</div>
<p>The important take-away is that by using protobufs and gRPC, Stratum
need not be concerned with the long list of formatting, reliability,
backwards compatibility, and security challenges that protocols
(including OpenFlow) have historically spent a great deal of time
worrying about. In addition, protobufs serve as a well-defined target
for the code generated by the P4 compiler, which is to say, the P4
toolchain outputs protobufs that specify the types and arguments for
the P4Runtime interface. This API, along with the client- and
server-side stubs that implement it, are (mostly) auto-generated.
Section 5.2 describes the toolchain for creating this
runtime contract in more detail.</p>
<p>Below Stratum, the architecture takes advantage of two components. The
first is a <em>Software Development Kit (SDK)</em> for the on-board switching
chip(s). These are provided by the switch vendor, and in the case of
Broadcom, it roughly corresponds to the OF-DPA layer described in
Section 4.5. Barefoot provides a similar SDK for their Tofino
chip. You can think of these SDKs as similar to device drivers in a
traditional OS: they are used to indirectly read and write memory
locations on the corresponding chip. The second is the <em>ONL Platform
(ONLP)</em>, which exports the Platform API shown in <a class="reference internal" href="#fig-stratum"><span class="std std-numref">Figure 24</span></a>. This API provides access hardware counters, monitors,
status variables, and so on.</p>
<p>As a simple example, which helps illustrate the fundamental difference
between fixed-function and programmable pipelines, Broadcom’s SDK
defines a <code class="docutils literal notranslate"><span class="pre">bcm_l3_route_create</span></code> method to update the L3 forwarding
table, whereas Barefoot’s corresponding pipeline-independent method is
<code class="docutils literal notranslate"><span class="pre">bf_table_write</span></code>.</p>
<p>Internal to Stratum, the rest of the components shown in
<a class="reference internal" href="#fig-stratum"><span class="std std-numref">Figure 24</span></a> are primarily designed to make
Stratum vendor-agnostic. In the case of a programmable chip like
Tofino, Stratum is largely pass-through: P4Runtime calls that come
from above are directly passed through to the Barefoot SDK. In the
case of a fixed-function chip like Tomahawk, Stratum maintains the
runtime state it needs to translate the P4Runtime calls into their
Broadcom SDK counterpart. To a first approximation, this implies
mapping P4Runtime calls to update table entries in a program like
<code class="docutils literal notranslate"><span class="pre">switch.p4</span></code> (Section 4.5.1) into Broadcom SDK calls to update
entries in one of the ASIC tables.</p>
</div>
<div class="section" id="p4runtime">
<h2>5.2 P4Runtime<a class="headerlink" href="#p4runtime" title="Permalink to this headline">¶</a></h2>
<p>You can think of the P4Runtime interface shown in <a class="reference internal" href="#fig-stratum"><span class="std std-numref">Figure 24</span></a> as the server-side RPC stub for controlling the
switch. There is a corresponding client-side stub, which is similarly
included in the SDN Controller. Together, they implement the
<em>P4Runtime Contract</em> between the controller and the switch. The
toolchain for generating this contract is shown in <a class="reference internal" href="#fig-toolchain"><span class="std std-numref">Figure 25</span></a>, where as in earlier figures, we represent the
original P4 forwarding program as an abstract graph rather than with
actual P4 source code.</p>
<div class="figure align-center" id="id4">
<span id="fig-toolchain"></span><a class="reference internal image-reference" href="_images/Slide18.png"><img alt="_images/Slide18.png" src="_images/Slide18.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Figure 25. </span><span class="caption-text">P4 toolchain achieves ASIC-independence and auto-generates
P4Runtime Contract (represented as a Protocol Buffer
specification).</span></p>
</div>
<p>One key takeaway from <a class="reference internal" href="#fig-toolchain"><span class="std std-numref">Figure 25</span></a> is that the
P4 compiler generates both the binary that is loaded into each
switching chip, and the <em>runtime interface</em> used to control the
switching chip (indirectly via the Switch OS).<a class="footnote-reference" href="#id2" id="id1">[1]</a> The compiler does
this with the help of a vendor-specific backend, where <a class="reference internal" href="#fig-toolchain"><span class="std std-numref">Figure
25</span></a> shows two possible examples. Note that these
vendor-specific backends have to be written for a specific
architecture model (as defined by <code class="docutils literal notranslate"><span class="pre">arch.p4</span></code> in this example).  In
other words, today it is a combination of the P4 language, the
ASIC-specific backend, and the architecture model that defines the
programming environment for injecting functionality into the data
plane.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>When we say the binary is loaded into the switching chip, we
are adopting familiar terminology from general-purpose
processors. The exact process is ASIC-specific, and might
include initializing various on-chip tables via the SDK.</td></tr>
</tbody>
</table>
<p>The final piece of the end-to-end story is the connection between the
runtime contract and the original program loaded into the data
plane. Using the simple forwarding program presented in Section 4.4 as
an example, we see that <code class="docutils literal notranslate"><span class="pre">forward.p4</span></code> defines a lookup table, which
we restate here:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="n">ipv4_lpm</span> <span class="p">{</span>
    <span class="n">key</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="nl">dstAddr</span><span class="p">:</span> <span class="n">lpm</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ipv4_forward</span><span class="p">;</span>
        <span class="n">drop</span><span class="p">;</span>
        <span class="n">NoAction</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="n">default_action</span> <span class="o">=</span> <span class="n">drop</span><span class="p">();</span>
</pre></div>
</div>
<p>Correspondingly, the file <code class="docutils literal notranslate"><span class="pre">forward.p4info</span></code> output by the compiler
<em>specifies</em> the P4Runtime Contract. As shown in the following example,
it contains enough information to fully inform both the controller and
switch on how to format and interpret the set of gRPC methods needed
to insert, read, modify, and delete entries in this table. For
example, the <code class="docutils literal notranslate"><span class="pre">table</span></code> definition identifies the field to match
(<code class="docutils literal notranslate"><span class="pre">hdr.ipv4.dstAddr</span></code>) and the type of match (<code class="docutils literal notranslate"><span class="pre">LPM</span></code>), along with the
three possible <code class="docutils literal notranslate"><span class="pre">actions</span></code>.</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="n">actions</span> <span class="p">{</span>
    <span class="n">preamble</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">16800567</span>
        <span class="n">name</span><span class="o">:</span> <span class="s">&quot;NoAction&quot;</span>
        <span class="n">alias</span><span class="o">:</span> <span class="s">&quot;NoAction&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">actions</span> <span class="p">{</span>
    <span class="n">preamble</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">16805608</span>
        <span class="n">name</span><span class="o">:</span> <span class="s">&quot;MyIngress.drop&quot;</span>
        <span class="n">alias</span><span class="o">:</span> <span class="s">&quot;drop&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">actions</span> <span class="p">{</span>
    <span class="n">preamble</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">16799317</span>
        <span class="n">name</span><span class="o">:</span> <span class="s">&quot;MyIngress.ipv4_forward&quot;</span>
        <span class="n">alias</span><span class="o">:</span> <span class="s">&quot;ipv4_forward&quot;</span>
    <span class="p">}</span>
    <span class="n">params</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">1</span>
        <span class="n">name</span><span class="o">:</span> <span class="s">&quot;dstAddr&quot;</span>
        <span class="n">bitwidth</span><span class="o">:</span> <span class="mi">48</span>
    <span class="p">}</span>
    <span class="n">params</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">2</span>
        <span class="n">name</span><span class="o">:</span> <span class="s">&quot;port&quot;</span>
        <span class="n">bitwidth</span><span class="o">:</span> <span class="mi">9</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">tables</span> <span class="p">{</span>
    <span class="n">preamble</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">33574068</span>
        <span class="n">name</span><span class="o">:</span> <span class="s">&quot;MyIngress.ipv4_lpm&quot;</span>
        <span class="n">alias</span><span class="o">:</span> <span class="s">&quot;ipv4_lpm&quot;</span>
    <span class="p">}</span>
    <span class="n">match_fields</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">1</span>
        <span class="n">name</span><span class="o">:</span> <span class="s">&quot;hdr.ipv4.dstAddr&quot;</span>
        <span class="n">bitwidth</span><span class="o">:</span> <span class="mi">32</span>
        <span class="n">match_type</span><span class="o">:</span> <span class="n">LPM</span>
    <span class="p">}</span>
    <span class="n">action_refs</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">16799317</span>
    <span class="p">}</span>
    <span class="n">action_refs</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">16805608</span>
    <span class="p">}</span>
    <span class="n">action_refs</span> <span class="p">{</span>
        <span class="n">id</span><span class="o">:</span> <span class="mi">16800567</span>
    <span class="p">}</span>
    <span class="n">size</span><span class="o">:</span> <span class="mi">1024</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The gRPC toolchain takes over from there. For this to work, the
toolchain must be aware of which P4 language elements are
controllable, and hence, available to be “exposed” by
<code class="docutils literal notranslate"><span class="pre">p4runtime.proto</span></code>. Such information is contained in
<code class="docutils literal notranslate"><span class="pre">forward.p4info</span></code>, which specifies exactly the set of controllable
elements and their attributes as defined in the source P4 program. (In
principle, there is no need to create such P4Info file, as the
controller and switch can use the source P4 program to derive all the
information they need to handle P4Rutime methods. However, P4Info
makes that much easier by extracting the relevant information from the
P4 program and providing them in a more structured protobuf-defined
format, which is straightforward to parse by using a protobuf
library.) The table element is one obvious example, but there are
others, including <code class="docutils literal notranslate"><span class="pre">counters</span></code> and <code class="docutils literal notranslate"><span class="pre">meters</span></code>, which are used to
report status information up to the controller and to allow the
controller to specify a QoS rate, respectively, but neither are
included in our example program.</p>
<p>Finally, a controller actually writes an entry to this table. While in
general this controller would run on top of ONOS, and so indirectly
interact with the switch, we can look at a simpler example in which a
Python program implements the controller, and writes an entry directly
into the table (assisted by a P4Runtime library).</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">p4runtime_lib.helper</span>
<span class="o">...</span>
<span class="n">table_entry</span> <span class="o">=</span> <span class="n">p4info_helper</span><span class="o">.</span><span class="n">buildTableEntry</span><span class="p">(</span>
    <span class="n">table_name</span><span class="o">=</span><span class="s2">&quot;MyIngress.ipv4_lpm&quot;</span><span class="p">,</span>
    <span class="n">match_fields</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;hdr.ipv4.dstAddr&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">dst_ip_addr</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="n">action_name</span><span class="o">=</span><span class="s2">&quot;MyIngress.ipv4_forward&quot;</span><span class="p">,</span>
    <span class="n">action_params</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;dstAddr&quot;</span><span class="p">:</span> <span class="n">next_hop_mac_addr</span><span class="p">,</span>
        <span class="s2">&quot;port&quot;</span><span class="p">:</span> <span class="n">outport</span><span class="p">,</span>
    <span class="p">})</span>
<span class="n">ingress_sw</span><span class="o">.</span><span class="n">WriteTableEntry</span><span class="p">(</span><span class="n">table_entry</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="gnmi-and-gnoi">
<h2>5.3 gNMI and gNOI<a class="headerlink" href="#gnmi-and-gnoi" title="Permalink to this headline">¶</a></h2>
<p>A core challenge of configuring and operating any network device is to
define the set of variables available for operators to <code class="docutils literal notranslate"><span class="pre">GET</span></code> and
<code class="docutils literal notranslate"><span class="pre">SET</span></code> on the device, with the additional requirement that this
dictionary of variables be uniform across devices (i.e., be
vendor-agnostic). The Internet has already gone through one
decades-long exercise defining such a dictionary, resulting in the
<em>Management Information Base (MIB)</em> used in conjunction with SNMP. But
the MIB was more focused on <em>reading</em> device status variables than
<em>writing</em> device configuration variables, where the latter has
historically been done using the device’s <em>Command Line Interface
(CLI)</em>. One consequence of the SDN transformation is to nudge the
industry towards support for programmatic configuration APIs. This
means revisiting the information model for network devices.</p>
<p>The main technical advance that was not prevalent in the early days of
SNMP and MIB is the availability of pragmatic modeling languages,
where YANG is the leading choice to have emerged over the last few
years. YANG—which stands for <em>Yet Another Next Generation</em>, a name
chosen to poke fun at how often a do-over proves necessary—can be
viewed as a restricted version of XSD, which is a language for
defining a schema for XML. YANG defines the structure of the data, but
unlike XSD, it is not XML-specific. Instead, YANG can be used in
conjunction with different over-the-wire message formats, including
XML, but also protobufs and JSON. If these acronyms are unfamiliar, or
the distinction between a markup language and a schema for a markup
language is fuzzy, a gentle introduction is available online.</p>
<div class="admonition-further-reading admonition" id="reading-xml">
<p class="first admonition-title">Further Reading</p>
<p class="last"><a class="reference external" href="https://book.systemsapproach.org/data/presentation.html#markup-languages-xml">Markup Languages (XML)</a>.
<em>Computer Networks: A Systems Approach</em>, 2020.</p>
</div>
<p>What’s important about going in this direction is that the data model
that defines the semantics of the variables available to be read and
written is available in a programmatic form; it’s not just text in a
standards document. Moreover, while it is true that all hardware
vendors promote the unique capabilities of their products, it is not a
free-for-all with each vendor defining a unique model. This is because
the network operators that buy network hardware have a strong
incentive to drive the models for similar devices towards convergence,
and vendors have an equally strong incentive to adhere to those
models. YANG makes the process of creating, using, and modifying
models programmable, and hence, adaptable to this iterative process.</p>
<p>This is where an industry-wide standardization effort, called
<em>OpenConfig</em>, comes into play. OpenConfig is a group of network
operators trying to drive the industry towards a common set of
configuration models using YANG as its modeling language. OpenConfig
is officially agnostic as to the over-the-wire protocol used to access
on-device configuration and status variables, but gNMI (gRPC Network
Management Interface) is one approach it is actively pursuing. And as
you might guess from its name, gNMI uses gRPC (which in turn runs on
top of HTTP/2). This means gNMI also adopts protobufs as the way it
specifies the data actually communicated over the HTTP
connection. Thus, gNMI is intended as a standard management interface
for network devices.</p>
<p>For completeness, note that NETCONF is another of the post-SNMP
protocols for communicating configuration information to network
devices. OpenConfig also works with NETCONF, but our reading of the
tea leaves points to gNMI as the future transport protocol, and so it
is the one we highlight in our description of the full SDN software
stack.</p>
<div class="sidebar">
<p class="first sidebar-title">Cloud Best-Practices</p>
<p>Our commentary on OpenConfig vs NETCONF is grounded in a
fundamental tenant of SDN, which is about bringing best
practices in cloud computing to the network. It involves big
ideas like implementing the network control plane as a
scalable cloud service, but it also includes more narrow
benefits, such as using modern transport protocols like
gRPC/protobufs.</p>
<p class="last">The advantages in this particular case are tangible: (1)
improved and optimized transport using HTTP/2 and
protobuf-based marshalling instead of SSH plus hand-code
marshalling; (2) binary data encodings instead of text-based
encoding; (3) diff-oriented data exchange instead of
snapshot-based responses; and (4) native support for server
push and client streaming</p>
</div>
<p>OpenConfig defines a hierarchy of object types. For example, the YANG
model for network interfaces looks like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span>Module: openconfig-interfaces
        +--rw interfaces
                +--rw interface*   [name]
                        +--rw name
                        +--rw config
                         |   ...
                        +--ro state
                         |    ...
                        +--rw hold-time
                         |    ...
                        +--rw subinterfaces
                         |    ...
</pre></div>
</div>
<p>This is a base model that can be augmented, for example, to model an Ethernet interface:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span>Module: openconfig-if-ethernet
        augment /ocif:interfaces/ocif:interface:
                +--rw ethernet
                +--rw config
                 |      +--rw mac-address?
                 |      +--rw auto-negotiate?
                 |      +--rw duplex-mode?
                 |      +--rw port-speed?
                 |      +--rw enable-flow-control?
                +--ro state
                        +--ro mac-address?
                        +--ro auto-negotiate?
                        +--ro duplex-mode?
                        +--ro port-speed?
                        +--ro enable-flow-control?
                        +--ro hw-mac-address?
                        +--ro counters
                               ...
</pre></div>
</div>
<p>Other similar augmentations might be defined to support link
aggregation, IP address assignment, VLAN tags, and so on.</p>
<p>Each model in the OpenConfig hierarchy defines a combination of
configuration state that can be both read and written by the client
(denoted <code class="docutils literal notranslate"><span class="pre">rw</span></code> in the examples), and operational state that reports
device status (denoted <code class="docutils literal notranslate"><span class="pre">ro</span></code> in the examples, indicating it is
read-only from the client side). This distinction between declarative
configuration state and runtime feedback state is a fundamental aspect
of any network device interface, where OpenConfig is explicitly
focused on generalizing the latter to include network telemetry data
the operator needs to track.</p>
<p>Having a meaningful set of models is necessary, but a full
configuration system includes other elements as well. In our case,
there are three important points to make about the relationship
between Stratum and the OpenConfig models.</p>
<p>The first is that Stratum depends on a YANG toolchain. <a class="reference internal" href="#fig-yang"><span class="std std-numref">Figure
26</span></a> shows the steps involved in translating a set of
YANG-based OpenConfig models into the client-side and server-side gRPC
stubs used by gNMI. The gNMI Server shown in the figure is the same as
the gNMI interface portal shown in <a class="reference internal" href="#fig-stratum"><span class="std std-numref">Figure 24</span></a>. The toolchain supports multiple target programming
languages (Stratum happens to use C++), where the client and server
sides of the gRPC need not be written in the same language.</p>
<div class="figure align-center" id="id5">
<span id="fig-yang"></span><a class="reference internal image-reference" href="_images/Slide25.png"><img alt="_images/Slide25.png" src="_images/Slide25.png" style="width: 550px;" /></a>
<p class="caption"><span class="caption-number">Figure 26. </span><span class="caption-text">YANG toolchain used to generate gRPC-based runtime for gNMI.</span></p>
</div>
<p>Keep in mind that YANG is not tied to either gRPC or gNMI. The
toolchain is able to start with the very same OpenConfig models, but
instead produce XML or JSON representations for the data being
read-from or written-to network devices using (for example) NETCONF or
RESTCONF, respectively. But in our context, the target is protobufs,
which Stratum uses to support gNMI running over gRPC.</p>
<p>The second is the specific set of gRPC methods defined by gNMI to
operate on these models. The set is defined collectively as a Service
in the protobuf specification:</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="n">Service</span> <span class="n">gNMI</span> <span class="p">{</span>
        <span class="k">rpc</span> <span class="n">Capabilities</span><span class="p">(</span><span class="n">CapabilityRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">CapabilityResponse</span><span class="p">);</span>
        <span class="k">rpc</span> <span class="n">Get</span><span class="p">(</span><span class="n">GetRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">GetResponse</span><span class="p">);</span>
        <span class="k">rpc</span> <span class="n">Set</span><span class="p">(</span><span class="n">SetRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">SetResponse</span><span class="p">);</span>
        <span class="k">rpc</span> <span class="n">Subscribe</span><span class="p">(</span><span class="n">stream</span> <span class="n">SubscribeRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">SubscribeResponse</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Capabilities</span></code> method is used to retrieve the set of model
definitions supported by the device. The <code class="docutils literal notranslate"><span class="pre">Get</span></code> and <code class="docutils literal notranslate"><span class="pre">Set</span></code> methods
are used to read and write the corresponding variable defined in some
model. The <code class="docutils literal notranslate"><span class="pre">Subscribe</span></code> method is used to set up a stream of
telemetry updates from the device. The corresponding arguments and
return values (e.g., <code class="docutils literal notranslate"><span class="pre">GetRequest</span></code>, <code class="docutils literal notranslate"><span class="pre">GetResponse</span></code>) are defined by a
defined by a protobuf <code class="docutils literal notranslate"><span class="pre">Message</span></code>, and include various fields from the
YANG models. A given field is specified by giving its fully qualified
path name in the data model tree.</p>
<p>The third point is that Stratum does not necessarily care about the
full range of OpenConfig models. This is because—as a Switch OS
designed to support a centralized Controller—Stratum cares about
configuring various aspects of the data plane, but is not typically
involved in configuring control plane protocols like BGP. Such control
plane protocols are no longer implemented on the switch in an
SDN-based solution (although they remain in scope for the Network OS,
which implements their centralized counterpart). To be specific,
Stratum tracks the following OpenConfig models: Interfaces, VLANs,
QoS, and LACP (link aggregation), in addition to a set of system and
platform variables (of which the switch’s fan speed is everyone’s
favorite example).</p>
<p>We conclude this section by briefly turning our attention to gNOI, but
there isn’t a lot to say. This is because the underlying mechanism
used by gNOI is exactly the same as for gNMI, and in the larger scheme
of things, there is little difference between a switch’s configuration
interface and its operations interface. Generally speaking, persistent
state is handled by gNMI (and a corresponding YANG model is defined),
whereas clearing or setting ephemeral state is handled by gNOI. It is
also the case that non-idempotent actions like reboot and ping tend to
fall under gNOI’s domain. In any case, the two are closely enough
aligned to collectively be referred to as gNXI.</p>
<p>As an illustrative example of what gNOI is used for, the following is
the protobuf specification for the <code class="docutils literal notranslate"><span class="pre">System</span></code> service:</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">service</span> <span class="n">System</span> <span class="p">{</span>
        <span class="k">rpc</span> <span class="n">Ping</span><span class="p">(</span><span class="n">PingRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">PingResponse</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">rpc</span> <span class="n">Traceroute</span><span class="p">(</span><span class="n">TracerouteRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">TracerouteResponse</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">rpc</span> <span class="n">Time</span><span class="p">(</span><span class="n">TimeRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">TimeResponse</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">rpc</span> <span class="n">SetPackage</span><span class="p">(</span><span class="n">stream</span> <span class="n">SetPackageRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">SetPackageResponse</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">rpc</span> <span class="n">Reboot</span><span class="p">(</span><span class="n">RebootRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">RebootResponse</span><span class="p">)</span> <span class="p">{}</span>
        <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where, for example, the following protobuf message defines the
<code class="docutils literal notranslate"><span class="pre">RebootRequest</span></code> parameter:</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span> <span class="nc">RebootRequest</span> <span class="p">{</span>
        <span class="n">RebootMethod</span> <span class="na">method</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// COLD, POWERDOWN, HALT, WARM, NSF, ...</span>
        <span class="kt">uint64</span> <span class="na">delay</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Delay in nanoseconds before issuing reboot.</span>
        <span class="kt">string</span> <span class="kd">message</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// Informational reason for the reboot.</span>
        <span class="k">repeated</span> <span class="n">types.Path</span> <span class="na">subcomponents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// Optional sub-components to reboot.</span>
        <span class="kt">bool</span> <span class="na">force</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// Force reboot if sanity checks fail. (ex. uncommited configuration)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As a reminder, if you are unfamiliar with protobufs, a brief overview is available online.</p>
<div class="admonition-further-reading admonition" id="reading-protobuf">
<p class="first admonition-title">Further Reading</p>
<p class="last"><a class="reference external" href="https://book.systemsapproach.org/e2e/presentation.html#protobufs">Protocol Buffers</a>.
<em>Computer Networks: A Systems Approach</em>, 2020.</p>
</div>
</div>
<div class="section" id="sonic">
<h2>5.4 SONiC<a class="headerlink" href="#sonic" title="Permalink to this headline">¶</a></h2>
<p>In the same way SAI is an industry-wide switch abstraction (see
Section 4.5), SONiC is a vendor-agnostic Switch OS that is gaining a
lot of momentum in the industry. SONiC, which leverages SAI as a
vendor-agnostic SDK and was originally open sourced by Microsoft,
continues to serve as the Switch OS for the Azure Cloud. And like
Stratum, SONiC can also leverage Open Networking Linux (ONL) as its
underlying operating system. All of which is to say that Stratum and
SONiC both try to fill the same need. Today their respective
approaches are largely complementary, with both open source
communities working towards a “best of both world” solution.</p>
<p>Both SONiC and Stratum support a configuration interface, so unifying
those will be a matter of reconciling their respective data models and
toolchains. The main distinction is Stratum’s support for programmable
forwarding pipelines (including both P4 and P4Runtime), versus the
least common denominator approach to forwarding taken by
SAI. Developers on the two open source projects are working together
to define a roadmap that will make it possible for interested networks
to take advantage of programmable pipelines in an incremental and
low-risk way.</p>
<p>The goal of this effort is to both (1) enable remote SDN
Controllers/Apps to interact with SAI using P4Runtime and gNMI,
and (2) enable SAI extensions using P4 so as to improve feature
velocity in the data plane. Both goals rely on a new representation of
the SAI behavioral model and pipeline based on a P4 program (the so
called <code class="docutils literal notranslate"><span class="pre">sai.p4</span></code> program shown in <a class="reference internal" href="switch.html#fig-compare"><span class="std std-numref">Figure 23</span></a>
of Section 4.6). If you take one thing away from this reconciliation
effort, it should be that embracing a programmable pipeline (and
corresponding toolchain) is what facilitates doing something like
this.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="onos.html" class="btn btn-neutral float-right" title="Chapter 6: Network OS" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="switch.html" class="btn btn-neutral float-left" title="Chapter 4: White-Box Switches" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
