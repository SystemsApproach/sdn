

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapter 8: Future of SDN &mdash; Software-Defined Networks: A Systems Approach Version 0.3-dev documentation</title>
  

  
  
    <link rel="shortcut icon" href="static/bridge.ico"/>
  
  
  

  
  <script type="text/javascript" src="static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
        <script type="text/javascript" src="static/jquery.js"></script>
        <script type="text/javascript" src="static/underscore.js"></script>
        <script type="text/javascript" src="static/doctools.js"></script>
        <script type="text/javascript" src="static/language_data.js"></script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Hands-on Programming" href="exercises.html" />
    <link rel="prev" title="Chapter 7: Leaf-Spine Fabric" href="trellis.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Software-Defined Networks: A Systems Approach
          

          
          </a>

          
            
            
              <div class="version">
                Version 0.3-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Chapter 1:  Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="uses.html">Chapter 2:  Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="arch.html">Chapter 3:  Basic Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="switch.html">Chapter 4:  White-Box Switches</a></li>
<li class="toctree-l1"><a class="reference internal" href="stratum.html">Chapter 5:  Switch OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="onos.html">Chapter 6:  Network OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="trellis.html">Chapter 7:  Leaf-Spine Fabric</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chapter 8:  Future of SDN</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#verifiable-networks">8.1 Verifiable Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sd-ran">8.2 SD-RAN</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">Hands-on Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html">About The Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">About The Authors</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Software-Defined Networks: A Systems Approach</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Chapter 8:  Future of SDN</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/future.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="exercises.html" class="btn btn-neutral float-right" title="Hands-on Programming" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="trellis.html" class="btn btn-neutral float-left" title="Chapter 7: Leaf-Spine Fabric" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="chapter-8-future-of-sdn">
<h1>Chapter 8:  Future of SDN<a class="headerlink" href="#chapter-8-future-of-sdn" title="Permalink to this headline">¶</a></h1>
<p>It is still early days for SDN. Cloud-hosted control planes are being
deployed in production networks, but we are only just starting to see
SDN being trialed in access networks and programmable pipelines being
used to introduce new data plane functionality. As the technology
matures and the APIs stabilize we expect to see increased adoption,
but it may be new use cases still on the horizon that have the biggest
impact on the role SDN eventually plays. This chapter looks at two
promising examples.</p>
<div class="section" id="verifiable-networks">
<h2>8.1 Verifiable Networks<a class="headerlink" href="#verifiable-networks" title="Permalink to this headline">¶</a></h2>
<p>Networks are notoriously difficult to make verifiably robust and
secure against failures, attacks, and configuration mistakes. Despite
progress on application-level security, little has been done to
address the security and robustness of the underlying network
infrastructure. And despite progress making computer networks more
programmable, most networks are still built using closed/proprietary
software and complex/fixed-function hardware, whose correctness is
hard to prove and whose design has unknown provenance.</p>
<p>The emergence of 5G networks and applications will only exacerbate the
situation. 5G networks will connect not only smart phones and people,
but also everything from doorbells, to lights, refrigerators,
self-driving cars, and drones. If we cannot secure these networks, the
risk of cyber disasters is much worse than anything experienced to
date.</p>
<p>The most critical capability for securing the Internet is verifiability:
the ability to ensure that every packet in the network follows an
operator-specified path and encounters only a set of forwarding rules
within every device that the operator intended. Nothing more and
nothing less.</p>
<p>Experience has shown that verification works best in settings where
the overall system is constructed in a compositional (i.e.,
disaggregated) manner. Being able to reason about small pieces makes
verification tractable, and the reasoning needed to stitch the
components together into the composite system can also lead to
insights. With disaggregation as the foundation, verifiability follows
from (a) the ability to state intent, and (b) the ability to observe
behavior at fine granularity and in real-time. This is exactly the
value SDN brings to the table, which leads to optimism that
<em>verifiable closed-loop control</em> is now within reach.</p>
<div class="admonition-further-reading admonition" id="reading-pronto">
<p class="first admonition-title">Further Reading</p>
<p class="last">N. Foster, et. al. <a class="reference external" href="http://www.systemsapproach.org/uploads/4/7/7/4/47748257/pronto_ccr_2020.pdf">Using Deep Programmability to Put Network
Owners in Control</a>.
ACM SIGCOMM Computer Communication Review, October 2020.</p>
</div>
<p><a class="reference internal" href="#fig-closed-loop"><span class="std std-numref">Figure 39</span></a> illustrates the basic idea.  The
software stack described in this book is augmented with the
measurement, code generation, and verification elements needed for
verifiable closed-loop control. Fine-grained measurements can be
implemented using INT (Inband Network Telemetry), which allows every
packet to be stamped by the forwarding elements to indicate the path
it took, the queueing delay it experienced, and the rules it matched.
These measurements can then be analyzed and fed back into code
generation and formal verification tools. This closed loop complements
the intrinsic value of disaggregation, which makes it possible to
reason about correctness-by-construction.</p>
<div class="figure align-center" id="id3">
<span id="fig-closed-loop"></span><a class="reference internal image-reference" href="_images/Slide30.png"><img alt="_images/Slide30.png" src="_images/Slide30.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Figure 39. </span><span class="caption-text">INT generates fine-grain measurements, which in turn feed a closed
control loop that verifies the network’s behavior.</span></p>
</div>
<div class="sidebar">
<p class="first sidebar-title">Top-Down Verification</p>
<p>The approach to verifying networks described in this section is
similar to the one used in chip design. At the top is a behavioral
model; then at the register-transfer level is a Verilog or VHDL
model; and eventually at the bottom are transistors, polygons and
metal. Tools are used to formally verify correctness across each
boundary and abstraction level.</p>
<p>This is a model for what we are talking about here: Verifying
across boundaries in a top-down design approach. This is made
possible by the new SDN interfaces and abstractions defined by the
software stack, which extends all the way to the programmable
forwarding pipelines provided by the switching chip.</p>
<p class="last">As experience with hardware verification demonstrates, this
approach works best in composed systems, where each minimal
component can be verified or reliably tested on its own. Formal
tools are then applied as components are composed at layer
boundaries.</p>
</div>
<p>The goal is to enable network operators to specify a network’s
behavior top-down, and then verifying the correctness across each
interface. At the lowest level, P4 programs specify how packets are
processed; these programs are compiled to run on the forwarding plane
elements. Such an approach represents a fundamental new capability
that has not been possible in conventional designs, based on two key
insights.</p>
<p>First, while network control planes are inherently complicated, a P4
data plane captures <em>ground truth</em> for the network—i.e., how it
forwards packets—and is therefore an attractive platform for deploying
verification technologies. By observing and then validating behavior
at the data plane level, it is possible to reduce the trusted
computing base: the switch operating system, driver, and other
low-level components do not need to be trusted. Moreover, whereas the
control plane tends to be written in a general-purpose language and is
correspondingly complex, the data plane is necessarily simple: it is
ultimately compiled to an efficient, feed-forward pipeline
architecture with simple data types and limited state. While verifying
general-purpose software is impossible in the general case, data plane
verification is both powerful and practical.</p>
<p>This claim of practicality is grounded in the current
state-of-the-art.  Once the forwarding behavior is defined and known,
then forwarding table state defines forwarding behavior. For example,
if everything is known to be IPv4 forwarded, then the forwarding table
state in all routers is enough to define the network behavior. This
idea has been reduced to practice by techniques like Veriflow and
Header Space Analysis (HSA), and is now available commercially.
Knowing that this state is enough to verify networks with fixed
forwarding behavior means that we are “merely” adding one new
degree-of-freedom: allowing the network operator to program the
forwarding behavior (and evolve it over time) using P4. The use of P4
to program the data plane is key: the language carefully excludes
features such as loops and pointer-based data structures, which
typically make analysis impractical. To read more about the
opportunity, we recommend a paper by Jed Liu and colleagues.</p>
<div class="admonition-further-reading admonition" id="reading-p4">
<p class="first admonition-title">Further Reading</p>
<p class="last">J. Liu, et. al. <a class="reference external" href="http://yuba.stanford.edu/~nickm/papers/p4v.pdf">p4v: Practical Verification for Programmable Data Planes</a>. ACM
SIGCOMM 2018.</p>
</div>
<p>The second insight is that, in addition to building tools for
analyzing network programs, it is important to also develop
technologies that provide higher levels of assurance through
<em>defense-in-depth</em>. This addresses one of the main weaknesses of
current approaches to network verification—they are based on
mathematical models of the network components, and therefore can
produce incorrect answers when those components behave in different
ways than are captured in the model. By exploiting the ability of P4
data planes to collect rich telemetry and other monitoring data, it is
possible to develop network verification tools that combine
statically-verified components with runtime verification.</p>
<div class="figure align-center" id="id4">
<span id="fig-phase3"></span><a class="reference internal image-reference" href="_images/Slide37.png"><img alt="_images/Slide37.png" src="_images/Slide37.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Figure 40. </span><span class="caption-text">Projecting into the future, with Phase 3 of SDN focusing on
verifiable, top-down control of network behavior.</span></p>
</div>
<p>To put this all in an historical context, Section 1.3 suggests we are
now in the second phase of SDN. <a class="reference internal" href="#fig-phase3"><span class="std std-numref">Figure 40</span></a>
extends this into the future with a third phase, during which
verifiable closed loop control will empower network operators to take
full ownership of the software that defines their networks. This gives
network owners the ability to tailor their networks in ways that
differentiate them from their competitors.</p>
</div>
<div class="section" id="sd-ran">
<h2>8.2 SD-RAN<a class="headerlink" href="#sd-ran" title="Permalink to this headline">¶</a></h2>
<p>Much of the early hype surrounding 5G is about the increase in
bandwidth it brings, but 5G’s promise is mostly about the transition
from a single access service (broadband connectivity) to a richer
collection of edge services and devices, including support for
immersive user interfaces (e.g., AR/VR), mission-critical applications
(e.g., public safety, autonomous vehicles), and the Internet-of-Things
(IoT). Many of these new applications will be feasible only if SDN
principles are applied to the Radio Access Network (RAN), resulting in
increased feature velocity. Because of this, mobile network operators
are working to make Software-Defined RAN (SD-RAN) happen.</p>
<div class="admonition-further-reading admonition" id="reading-sdran">
<p class="first admonition-title">Further Reading</p>
<p class="last"><a class="reference external" href="https://opennetworking.org/sd-ran/">SD-RAN Project</a>.
Open Networking Foundation. August 2020.</p>
</div>
<p>To understand SD-RAN at a technical level, it is important to
recognize that the base stations that make up the RAN are, for all
practical purposes, packet forwarders. The set of base stations in a
given geographic area coordinate with each other to allocate the
shared—and extremely scarce—radio spectrum. They make hand-off
decisions, decide to jointly serve a given user (think of this as a
RAN variant of link aggregation), and make packet scheduling decisions
based on the observed signal quality. Today these are purely local
decisions, but transforming it into a global optimization problem is
in SDN’s wheelhouse.</p>
<p>The idea of SD-RAN is for each base station to report locally
collected statistics about radio transmission quality back to a
central SDN controller, which combines information from a set of base
stations to construct a global view of how the radio spectrum is being
utilized. A suite of control applications—for example, one focused on
handoffs, one focused on link aggregation, one focused on load
balancing, and one focused on frequency management—can then use this
information to make globally optimal decisions, and push control
instructions back to the individual base stations. These control
instructions are not at the granularity of scheduling individual
segments for transmission (i.e., there is still a real-time scheduler
on each base station, just as an SDN-controlled ethernet switch still
has a local packet scheduler), but they do exert near real-time
control over the base stations, with control loops measured in less
than ten milliseconds.</p>
<div class="figure align-center" id="id5">
<span id="fig-ric"></span><a class="reference internal image-reference" href="_images/Slide36.png"><img alt="_images/Slide36.png" src="_images/Slide36.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Figure 41. </span><span class="caption-text">3GPP-compliant RAN Intelligent Controller (RIC) built by adapting
and extending ONOS.</span></p>
</div>
<p>Like the verified closed-loop control example, the scenario just
described is within reach, with a retargeting of ONOS at the SD-RAN
use case already underway. <a class="reference internal" href="#fig-ric"><span class="std std-numref">Figure 41</span></a> shows the
design, which introduces some new components, but largely builds on
the existing ONOS architecture. In some cases, the changes are
superficial. For example, ONOS adopts terminology coming out of the
3GPP and O-RAN standardization bodies,<a class="footnote-reference" href="#id2" id="id1">[1]</a> most notably, that the
NOS is called a <em>RAN Intelligent Controller (RIC)</em>. In other cases,
it’s a matter of adopting standardized interfaces: the <strong>C1</strong>
interface by which control applications communicate with the RIC, the
<strong>A1</strong> interface by which the operator configures the RAN, and the
<strong>E2</strong> interface by which the RIC communicates with the underlying RAN
elements. The details of these interfaces is beyond the scope of this
book, but the important takeaway for our purposes is that they are no
different than supporting any other standard north- and south-facing
interface (e.g., gNMI, gNOI, OpenFlow).</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>3GPP (3rd Generation Partnership Project) has been responsible for
standardizing the mobile cellular network ever since 3G, and
O-RAN (Open-RAN Alliance) is a consortium of mobile network
operators defining an SDN-based implementation strategy for 5G.</td></tr>
</tbody>
</table>
<p>The ONOS-based RIC takes advantage of the Topology Service described
in Chapter 6, but it also introduces two new services: <em>Control</em> and
<em>Telemetry</em>. The Control Service, which builds on the Atomix key/value
store, manages the control state for all the base stations and user
devices, including which base station is serving each user device, as
well as the set of  “potential links” that could connect the device.
The Telemetry Service, which builds on a <em>Time Series Database
(TSDB)</em>, tracks all the link quality information being reported back
by the RAN elements. Various of the control applications then analyze
this data to make informed decisions about how the RAN can best meet
its data delivery objectives.</p>
<p>For a broad introduction into what’s involved in disaggregating 5G
mobile networks so they can be implemented in software, we recommend
the following companion book.</p>
<div class="admonition-further-reading admonition" id="reading-5g">
<p class="first admonition-title">Further Reading</p>
<p class="last">L. Peterson and O. Sunay.
<a class="reference external" href="https://5g.systemsapproach.org/">5G Mobile Networks: A Systems Approach</a>.
June 2020.</p>
</div>
<p>Finally, circling back to the previous section, applying closed-loop
verification to a disaggregated and software-defined cellular network
is the next obvious thing to do.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="exercises.html" class="btn btn-neutral float-right" title="Hands-on Programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="trellis.html" class="btn btn-neutral float-left" title="Chapter 7: Leaf-Spine Fabric" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
