

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapter 4: White-Box Switches &mdash; Software-Defined Networks: A Systems Approach Version 0.3-dev documentation</title>
  

  
  
    <link rel="shortcut icon" href="static/bridge.ico"/>
  
  
  

  
  <script type="text/javascript" src="static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
        <script type="text/javascript" src="static/jquery.js"></script>
        <script type="text/javascript" src="static/underscore.js"></script>
        <script type="text/javascript" src="static/doctools.js"></script>
        <script type="text/javascript" src="static/language_data.js"></script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Chapter 5: Switch OS" href="stratum.html" />
    <link rel="prev" title="Chapter 3: Basic Architecture" href="arch.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Software-Defined Networks: A Systems Approach
          

          
          </a>

          
            
            
              <div class="version">
                Version 0.3-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Chapter 1:  Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="uses.html">Chapter 2:  Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="arch.html">Chapter 3:  Basic Architecture</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chapter 4:  White-Box Switches</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#switch-level-schematic">4.1 Switch-Level Schematic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#forwarding-pipeline">4.2 Forwarding Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="#abstracting-the-pipeline">4.3 Abstracting the Pipeline</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#v1model">4.3.1 V1Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tna">4.3.2 TNA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#p4-programs">4.4 P4 Programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#header-declarations-and-metadata">4.4.1 Header Declarations and Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parser">4.4.2 Parser</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ingress-processing">4.4.3 Ingress Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#egress-processing">4.4.4 Egress Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deparser">4.4.5 Deparser</a></li>
<li class="toctree-l3"><a class="reference internal" href="#switch-definition">4.4.6 Switch Definition</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fixed-function-pipelines">4.5  Fixed-Function Pipelines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#of-dpa">4.5.1 OF-DPA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sai">4.5.2 SAI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#comparison">4.6 Comparison</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="stratum.html">Chapter 5:  Switch OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="onos.html">Chapter 6:  Network OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="trellis.html">Chapter 7:  Leaf-Spine Fabric</a></li>
<li class="toctree-l1"><a class="reference internal" href="future.html">Chapter 8:  Future of SDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">Hands-on Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html">About The Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">About The Authors</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Software-Defined Networks: A Systems Approach</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Chapter 4:  White-Box Switches</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/switch.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="stratum.html" class="btn btn-neutral float-right" title="Chapter 5: Switch OS" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="arch.html" class="btn btn-neutral float-left" title="Chapter 3: Basic Architecture" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="chapter-4-white-box-switches">
<h1>Chapter 4:  White-Box Switches<a class="headerlink" href="#chapter-4-white-box-switches" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the white-box switches that provide the
underlying hardware foundation for SDN. Our goal is not to give a
detailed hardware schematic, but rather, to sketch enough of the
design to appreciate the software stack that runs on top of it. Also,
because we ultimately want to be vendor agnostic, this chapter
discusses both P4 as a language-based approach to programming the
switch’s data plane, and OpenFlow as the first-generation alternative.
(It is helpful to keep in mind that we introduce these two approaches
in reverse chronological order, starting with the more general
programmable case.)</p>
<div class="section" id="switch-level-schematic">
<h2>4.1 Switch-Level Schematic<a class="headerlink" href="#switch-level-schematic" title="Permalink to this headline">¶</a></h2>
<p>We start by considering a white-box switch as a whole, where the best
analogy is to imagine a PC built from a collection of commodity,
off-the-shelf components. In fact, a full architectural specification
for switches that take advantage of such components is available
on-line at the <em>Open Compute Project (OCP)</em>. This is the hardware
equivalent of open source software, and makes it possible for anyone
to build a high-performance switch, analogous to a home-built PC. But
just as the PC ecosystem includes commodity server vendors like Dell
and HP, you can buy a pre-built (OCP-compliant) switch from white-box
switch vendors such as EdgeCore, Delta and others.</p>
<p><a class="reference internal" href="#fig-switch"><span class="std std-numref">Figure 15</span></a> gives a high-level schematic of a
white-box switch. The <em>Network Processing Unit (NPU)</em>—a merchant
silicon switching chip—is optimized to parse packet headers and make
forwarding decisions. NPUs are able to process and forward packets at
rates measured in Terabits-per-second (Tbps), easily fast enough to
keep up with 32x100-Gbps ports, or the 48x40-Gbps ports shown in the
figure. As of this writing, the state-of-the-art for these chips is
25.6 Tbps with 400-Gbps ports.</p>
<div class="figure align-center" id="id9">
<span id="fig-switch"></span><a class="reference internal image-reference" href="_images/Slide10.png"><img alt="_images/Slide10.png" src="_images/Slide10.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Figure 15. </span><span class="caption-text">High-Level schematic of a white-box switch.</span></p>
</div>
<p>Note that our use of the term NPU is a bit non-standard. Historically,
NPU was the name given to more narrowly-defined network processing
chips used, for example, to implement intelligent firewalls or deep
packet inspection. They were not as general-purpose as the NPUs we are
discussing in this chapter, nor were they as high-performance. It
seems likely that the current merchant silicon switching chips will
make purpose-built network processors obsolete, but in any case, we
prefer the NPU nomenclature because it is consistent with the
industry-wide trend to build programmable domain-specific processors,
including GPUs (Graphic Processing Units) for graphics and TPUs
(Tensor Processing Units) for AI.</p>
<p><a class="reference internal" href="#fig-switch"><span class="std std-numref">Figure 15</span></a> shows the NPU as a combination of
SRAM-based memory that buffers packets while they are being processed,
and an ASIC-based forwarding pipeline that implements a series of
(Match, Action) pairs. We describe the forwarding pipeline in more
detail in the next section. The switch also includes a general-purpose
processor, typically an x86 chip, that controls the NPU. This is where
BGP or OSPF would run if the switch is configured to support an
on-switch control plane, but for our purposes, it’s where the Switch
OS runs, exporting an API that allows an off-switch, Network OS to
control the data plane. This control processor communicates with the
NPU, and is connected to an external management network, over a
standard PCIe bus.</p>
<p><a class="reference internal" href="#fig-switch"><span class="std std-numref">Figure 15</span></a> also shows other commodity
components that make this all practical. In particular, it is possible
to buy pluggable transceiver modules that take care of all the media
access details—be it 40-Gigabit Ethernet, 10-Gigabit PON, or SONET—as
well as the optics. These transceivers all conform to standardized
form factors, such as SFP+, that can in turn be connected to other
components over a standardized bus (e.g., SFI). Again, the key
takeaway is that the networking industry is now entering into the same
commoditized world that the computing industry has enjoyed for the
last two decades.</p>
<p>Finally, although not shown in <a class="reference internal" href="#fig-switch"><span class="std std-numref">Figure 15</span></a>, each
white-box switch includes a BIOS, which much like its microprocessor
counterpart, is firmware that provisions and boots a bare-metal
switch. A standard BIOS called the <em>Open Network Install Environment
(ONIE)</em> has emerged under the OCP’s stewardship, and so we assume ONIE
throughout the rest of the chapter.</p>
</div>
<div class="section" id="forwarding-pipeline">
<h2>4.2 Forwarding Pipeline<a class="headerlink" href="#forwarding-pipeline" title="Permalink to this headline">¶</a></h2>
<p>High-speed switches use a multi-stage pipeline to process packets. The
relevance of using a multi-stage pipeline rather than a single-stage
processor is that forwarding a single packet likely involves looking
at multiple header fields. Each stage can be programmed to look at a
different combination of fields. A multi-stage pipeline adds a little
end-to-end latency to each packet (measured in nanoseconds), but means
that multiple packets can be processed at the same time. For example,
Stage 2 can be making a second lookup on packet A while Stage 1 is
doing an initial lookup on packet B, and so on. This means the
pipeline as a whole is able to keep up with the aggregate bandwidth of
all its input ports. Repeating the numbers from Chapter 3, the
state-of-the-art is currently 25.6 Tbps.</p>
<p>The main distinction in how a given NPU implements this pipeline is
whether the stages are fixed-function (i.e., each stage understands
how to process headers for some fixed protocol) or programmable (i.e.,
each stage is dynamically programmed to know what header fields to
process). In the following discussion we start with the more general
case—a programmable pipeline—and return to its fixed-function
counterpart at the end.</p>
<p>At an architectural level, the programmable pipeline is often referred
to as a <em>Protocol Independent Switching Architecture (PISA)</em>.
<a class="reference internal" href="#fig-pisa1"><span class="std std-numref">Figure 16</span></a> gives a high-level overview of PISA,
which includes three major components. The first is a <em>Parser</em>, which
is programmed to define what header fields (and their location in the
packet) are to be recognized and matched by later stages. The second
is a sequence of <em>Match-Action Units</em>, each of which is programmed to
match (and potentially act upon) one or more of the identified header
fields. The third is the <em>Deparser</em>, which re-serializes the packet
metadata into the packet before it is transmitted on the output
link. The deparser reconstructs the over-the-wire representation for
each packet from all the in-memory header fields processed by earlier
stages.</p>
<p>Not shown in the figure is a collection of metadata about the packets
traversing the pipeline. This includes both per-packet state, such as
the input port and arrival timestamp, and flow-level state computed
across successive packets, such as switch counters and queue
depth. This metadata, which has an ASIC counterpart (e.g., a register),
is available for individual stages to read and write. It can also be
used by the Match-Action Unit, for example matching on the input port.</p>
<div class="figure align-center" id="id10">
<span id="fig-pisa1"></span><a class="reference internal image-reference" href="_images/Slide11.png"><img alt="_images/Slide11.png" src="_images/Slide11.png" style="width: 650px;" /></a>
<p class="caption"><span class="caption-number">Figure 16. </span><span class="caption-text">High-level overview of PISA’s multi-stage pipeline.</span></p>
</div>
<p>The individual Match-Action Units in <a class="reference internal" href="#fig-pisa1"><span class="std std-numref">Figure 16</span></a>
deserve a closer look. The memory shown in the figure is typically
built using a combination of SRAM and TCAM: it implements a table that
stores bit patterns to be matched in the packets being processed. The
relevance of the specific combination of memories is that TCAM is more
expensive and power-hungry than SRAM, but it is able to support
wildcard matches. Specifically, the “CAM” in TCAM stands for “Content
Addressable Memory,” which means that the key you want to look up in a
table can effectively be used as the address into the memory that
implements the table. The “T” stands for “Ternary” which is a
technical way to say the key you want to look up can have wildcards in
it (e.g., key 10*1 matches both 1001 and 1011). From the
software perspective, the main takeaway is that wildcard matches are
more expensive than exact matches, and should be avoided when
possible.</p>
<p>The ALU shown in the figure then implements the action paired with the
corresponding pattern. Possible actions include modifying specific
header fields (e.g., decrementing a TTL), pushing or popping tags
(e.g., VLAN, MPLS), incrementing or clearing various counters internal
to the switch (e.g., packets processed), and setting user/internal
metadata (e.g. the VRF ID to be used in the routing table).</p>
<p>Directly programming the parser, match-action units, and deparser
would be tedious, akin to writing microprocessor assembly code, so
instead we express the desired behavior using a high-level language
like P4, and depend on a compiler to generate the equivalent low-level
program. We will get to the specifics of P4 in a later section, so for
now we substitute an even more abstract representation of the desired
forwarding pipeline: the graphical depiction included in
<a class="reference internal" href="#fig-pisa2"><span class="std std-numref">Figure 17</span></a>. (To be consistent with other
examples, we call this program <code class="docutils literal notranslate"><span class="pre">forward.p4</span></code>.) This example program
first matches L2 header fields, then matches either IPv4 or IPv6
header fields, and finally applies some ACL rules to the packets
before allowing them through (e.g., think of the latter as firewall
filter rules). This is an example of the OpenFlow pipeline shown in
<a class="reference internal" href="intro.html#fig-pipeline"><span class="std std-numref">Figure 7</span></a> of Section 1.2.3.</p>
<p>In addition to translating the high-level representation of the
pipeline onto the underlying PISA stages, the P4 compiler is also
responsible for allocating the available PISA resources, in this case,
slots (rows) for the available Match-Action Units (of which
<a class="reference internal" href="#fig-pisa2"><span class="std std-numref">Figure 17</span></a> shows four, just as in <a class="reference internal" href="#fig-pisa1"><span class="std std-numref">Figure
16</span></a>). Allocating slots in the available Match-Action units
is the P4/PISA counterpart of register allocation for a conventional
programming language running on a general-purpose microprocessor. In
our example, we assume there are many more IPv4 Match-Action rules
than IPv6 or ACL rules, so the compiler allocates entries in the
available Match-Action Units accordingly.</p>
<div class="figure align-center" id="id11">
<span id="fig-pisa2"></span><a class="reference internal image-reference" href="_images/Slide12.png"><img alt="_images/Slide12.png" src="_images/Slide12.png" style="width: 650px;" /></a>
<p class="caption"><span class="caption-number">Figure 17. </span><span class="caption-text">Depiction of the desired forwarding behavior (as specified by a
pictorial representation of a P4 program) mapped onto PISA.</span></p>
</div>
</div>
<div class="section" id="abstracting-the-pipeline">
<h2>4.3 Abstracting the Pipeline<a class="headerlink" href="#abstracting-the-pipeline" title="Permalink to this headline">¶</a></h2>
<p>The next piece of the puzzle is to account for different switching
chips implementing different physical pipelines. To do this we need an
abstract (canonical) pipeline that is general enough to fairly
represent the available hardware, plus a definition of how the
abstract pipeline maps onto the physical pipeline. With such a logical
model for the pipeline, we will be able to support pipeline-agnostic
controllers, as illustrated in <a class="reference internal" href="#fig-logical"><span class="std std-numref">Figure 18</span></a>.</p>
<p>Ideally, there will be just one logical pipeline, and the P4 compiler
will be responsible for mapping that logical pipeline into various
physical counterparts. Unfortunately, the marketplace has not yet
converged on a single logical pipeline, but let’s put that
complication aside for now. On the other side of the equation, there
are currently on the order of ten target ASICs that this approach
needs to account for. There are many more than ten switch vendors, but
in practice, it is only those built for the high-end of the market
that come into play.</p>
<div class="figure align-center" id="id12">
<span id="fig-logical"></span><a class="reference internal image-reference" href="_images/Slide16.png"><img alt="_images/Slide16.png" src="_images/Slide16.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Figure 18. </span><span class="caption-text">Defining a logical pipeline as a general approach to supporting a
pipeline-agnostic control plane.</span></p>
</div>
<p>How do we specify the logical pipeline? This is also done with a P4
program, resulting in the situation shown in <a class="reference internal" href="#fig-psa"><span class="std std-numref">Figure 19</span></a>. Notice that we are revisiting the two P4 programs
introduced in <a class="reference internal" href="arch.html#fig-stack"><span class="std std-numref">Figure 12</span></a>. The first program
(<code class="docutils literal notranslate"><span class="pre">forward.p4</span></code>) defines the functionality we want from the available
switching chip. This program is written by the developers that want to
establish the behavior of the data plane. The second program
(<code class="docutils literal notranslate"><span class="pre">arch.p4</span></code>) is essentially a header file: it represents a contract
between the P4 program and the P4 compiler. Specifically, <code class="docutils literal notranslate"><span class="pre">arch.p4</span></code>
defines what P4-programmable blocks are available, the interface for
each stage, and the capability for each stage. Who is responsible for
writing such an architecture program? The P4 Consortium is one source
of such a definition, but different switch vendors have created their
own architectures to closely describe the capabilities of their
switching chips. This makes sense because there is a tension between
having a single common architecture that enables executing the same P4
program on different ASICs from different vendors, and having an
architecture that best represents the differentiating capabilities of
any given ASIC.</p>
<p>The example shown in <a class="reference internal" href="#fig-psa"><span class="std std-numref">Figure 19</span></a> is called the
<em>Portable Switch Architecture (PSA)</em>. It is intended to provide P4
developers implementing forwarding programs like <code class="docutils literal notranslate"><span class="pre">forward.p4</span></code> with
an abstract target machine, analogous to a Java Virtual Machine. The
goal is the same as for Java: to support a <em>write-once-run-anywhere</em>
programming paradigm. (Note that <a class="reference internal" href="#fig-psa"><span class="std std-numref">Figure 19</span></a>
includes the generic <code class="docutils literal notranslate"><span class="pre">arch.p4</span></code> as the the architecture model spec,
but in practice the architecture model would PSA specific, such as
<code class="docutils literal notranslate"><span class="pre">psa.p4</span></code>.)</p>
<div class="figure align-center" id="id13">
<span id="fig-psa"></span><a class="reference internal image-reference" href="_images/Slide13.png"><img alt="_images/Slide13.png" src="_images/Slide13.png" style="width: 650px;" /></a>
<p class="caption"><span class="caption-number">Figure 19. </span><span class="caption-text">P4 architecture known as the Portable Switch Architecture
(PSA). Includes the generic <code class="docutils literal notranslate"><span class="pre">arch.p4</span></code> as the the architecture
model spec, but for PSA this would be replaced by <code class="docutils literal notranslate"><span class="pre">psa.p4</span></code>.</span></p>
</div>
<p>When compared to the simpler PISA model used in <a class="reference internal" href="#fig-pisa1"><span class="std std-numref">Figure 16</span></a> and <a class="reference internal" href="#fig-pisa2"><span class="std std-numref">17</span></a>, we see two major
differences. First, the pipeline includes a new fixed-function stage:
the <em>Traffic Manager</em>. This stage is responsible for queuing,
replicating, and scheduling packets. This stage can be configured in
well-defined ways (e.g., setting parameters such as queue size and
scheduling policy), but cannot be re-programmed in a general-purpose
way (e.g., to define a new scheduling algorithm). Second, the pipeline
is divided into two halves: <em>ingress processing</em> (to the left of the
Traffic Manager), and <em>egress processing</em> (to the right of the Traffic
Manager).</p>
<p>What exactly does <code class="docutils literal notranslate"><span class="pre">arch.p4</span></code> define? Essentially three things:</p>
<ol class="arabic simple">
<li>As implied by <a class="reference internal" href="#fig-psa"><span class="std std-numref">Figure 19</span></a>, it defines the
inter-block interface signatures in terms of input and output
signals (think “function parameters and return type”). The goal of
a P4 programmer is that of providing an implementation for each
P4-programmable block that takes the provided input signals, such
as the input port where a packet was received from, and writes to
the output signals to influence the behavior of the following
blocks (e.g., the output queue/port where a packet has to be
directed).</li>
<li>Type declarations for <em>externs</em>, which can be seen as additional
fixed-function services that are exposed by the target and which
can be invoked by a P4 programmer. Examples of such externs are
checksum and hash computation units, packet or byte counters,
ciphers to encrypt/decrypt the packet payload, and so on. The
implementation of such externs is <em>not</em> specified in P4 by the
architecture, but their interface is.</li>
<li>Extensions to core P4 language types, including alternative match
types (e.g., <code class="docutils literal notranslate"><span class="pre">range</span></code> and <code class="docutils literal notranslate"><span class="pre">lpm</span></code> described in Section 4.4.3).</li>
</ol>
<p>The P4 compiler (like all compilers) has a hardware-agnostic
<em>frontend</em> that generates an <em>Abstract Syntax Tree (AST)</em> for the
programs being compiled, and a hardware-specific <em>backend</em> that
outputs an ASIC-specific executable. <code class="docutils literal notranslate"><span class="pre">arch.p4</span></code> is simply a collection
of type and interface definitions.</p>
<div class="section" id="v1model">
<h3>4.3.1 V1Model<a class="headerlink" href="#v1model" title="Permalink to this headline">¶</a></h3>
<p>The PSA shown in <a class="reference internal" href="#fig-psa"><span class="std std-numref">Figure 19</span></a> is still a
work-in-progress. It represents an idealized architecture that sits
between the P4 developer and the underlying hardware, but the
architectural model that developers are coding to today is somewhat
simpler. That model, called V1Model, is shown in <a class="reference internal" href="#fig-v1model"><span class="std std-numref">Figure 20</span></a>. <a class="footnote-reference" href="#id2" id="id1">[1]</a> It does not include a re-parsing step after the
Traffic Manager. Instead it implicitly bridges all metadata from
ingress to egress processing. Also, V1Model includes a checksum
verification/update block, whereas PSA treats checksums as an extern,
and supports incremental computations at any point during
ingress/egress processing.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>V1Model was originally introduced as the reference architecture
for an earlier version of P4, known as P4_14, and was
subsequently used to ease the porting of P4 programs from P4_14
to P4_16.</td></tr>
</tbody>
</table>
<p>We will be using this simpler model throughout the rest of the
book. As an aside, the most important factor in why V1Model is widely
used and that is not the case for PSA, is that the switch vendors do
not provide the compiler backend that maps from PSA onto their
respective ASICs. Until that happens, PSA will remain a mostly “on
paper” artifact.</p>
<div class="figure align-center" id="id14">
<span id="fig-v1model"></span><a class="reference internal image-reference" href="_images/Slide22.png"><img alt="_images/Slide22.png" src="_images/Slide22.png" style="width: 650px;" /></a>
<p class="caption"><span class="caption-number">Figure 20. </span><span class="caption-text">V1Model used in practice to abstract away the details of different
physical forwarding pipelines. Developers write P4 to this
abstract architectural model.</span></p>
</div>
<p>When we say P4 developers “write to this model” we are being more
descriptive than you might think. In practice, every P4 program starts
with the following template, which literally has a code block for
every programmable element in the abstract depiction shown in
<a class="reference internal" href="#fig-v1model"><span class="std std-numref">Figure 20</span></a></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;core.p4&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;v1model.p4&gt;</span><span class="cp"></span>

<span class="cm">/* Headers */</span>
<span class="k">struct</span> <span class="nc">metadata</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">struct</span> <span class="nc">headers</span> <span class="p">{</span>
        <span class="n">ethernet_t</span>      <span class="n">ethernet</span><span class="p">;</span>
        <span class="n">ipv4_t</span>          <span class="n">ipv4</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Parser */</span>
<span class="n">parser</span> <span class="n">MyParser</span><span class="p">(</span>
                <span class="n">packet_in</span> <span class="n">packet</span><span class="p">,</span>
                <span class="n">out</span> <span class="n">headers</span> <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">standard_metadata_t</span> <span class="n">smeta</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* Checksum Verification */</span>
<span class="n">control</span> <span class="n">MyVerifyChecksum</span><span class="p">(</span>
                <span class="n">in</span> <span class="n">headers</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* Ingress Processing */</span>
<span class="n">control</span> <span class="n">MyIngress</span><span class="p">(</span>
                <span class="n">inout</span> <span class="n">headers</span> <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">standard_metadata_t</span> <span class="n">smeta</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* Egress Processing */</span>
<span class="n">control</span> <span class="n">MyEgress</span><span class="p">(</span>
                <span class="n">inout</span> <span class="n">headers</span> <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">standard_metadata_t</span> <span class="n">smeta</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* Checksum Update */</span>
<span class="n">control</span> <span class="n">MyComputeChecksum</span><span class="p">(</span>
                <span class="n">inout</span> <span class="n">headers</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* Deparser */</span>
<span class="n">parser</span> <span class="n">MyDeparser</span><span class="p">(</span>
                <span class="n">inout</span> <span class="n">headers</span> <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* Switch */</span>
<span class="n">V1Switch</span><span class="p">(</span>
        <span class="n">MyParser</span><span class="p">(),</span>
        <span class="n">MyVerifyChecksum</span><span class="p">(),</span>
        <span class="n">MyIngress</span><span class="p">(),</span>
        <span class="n">MyEgress</span><span class="p">(),</span>
        <span class="n">MyComputeChecksum</span><span class="p">(),</span>
        <span class="n">MyDeparser</span><span class="p">()</span>
<span class="p">)</span> <span class="n">main</span><span class="p">;</span>
</pre></div>
</div>
<p>That is, after including two definition files (<code class="docutils literal notranslate"><span class="pre">core.p4</span></code>,
<code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code>) and defining the packet headers that the pipeline is
going to process, the programmer writes P4 code blocks for parsing,
checksum verification, ingress processing, and so on. The final block
(<code class="docutils literal notranslate"><span class="pre">V1Switch</span></code>) is the “main” function that specifies all the pieces
are to be pulled together into a complete switch pipeline. As to the
details corresponding to every “…” in the template, we will return
to those in a later section. For now, the important point is that
<code class="docutils literal notranslate"><span class="pre">forward.p4</span></code> is a highly stylized program that gets its structure
from the abstract model defined in <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code>.</p>
</div>
<div class="section" id="tna">
<h3>4.3.2 TNA<a class="headerlink" href="#tna" title="Permalink to this headline">¶</a></h3>
<p>As just noted, V1Model is one of many possible pipeline
architectures. PSA is another, but it is also the case that different
switch vendors have provided their own architecture definitions. There
are different incentives for doing this. One is that vendors have
their own version of the multi-ASIC problem as they continue to
release new chips over time. Another is that it enables vendors to
expose unique capabilities of their ASICs without being constrained by
a standardization process. The <em>Tofino Native Architecture (TNA)</em>,
which is an architecture model defined by Barefoot for their family of
programmable switching chips, is an example.</p>
<p>We do not give this example because we plan to define TNA, but rather,
because having a second tangible example helps to illustrate all the
degrees of freedom available in this space. In effect, the P4 language
defines a general framework for writing programs (we’ll see the syntax
in the next section), but it’s not until you supply a P4 architecture
definition (generically we refer to this as <code class="docutils literal notranslate"><span class="pre">arch.p4</span></code>, but specific
examples are <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code>, <code class="docutils literal notranslate"><span class="pre">psa.p4</span></code>, and <code class="docutils literal notranslate"><span class="pre">tna.p4</span></code>) that a
developer is able to actually write and compile a forwarding program.</p>
<p>In contrast to <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code> and <code class="docutils literal notranslate"><span class="pre">psa.p4</span></code>, which aspire to
abstracting commonality across different switching chips,
architectures like <code class="docutils literal notranslate"><span class="pre">tna.p4</span></code> faithfully define the low-level
capabilities of a given chip. Often, such capabilities are those that
differentiate a chip like Tofino from the competition (For this
reason, the definition of such vendor/chip-specific architectures is
not public and often requires signing a non-disclosure agreement.)
When picking an architecture model for a new P4 program, it is
important to ask questions like: Which of the available architectures
are supported by the switches I intend to program? Does my program
need access to chip-specific capabilities (e.g., a P4 extern to
encrypt/decrypt packet payload) or can it rely solely on
common/non-differentiating features (e.g., simple match-action tables
or a P4 extern to count packets)? Do I want the P4 program I develop
to be public on GitHub?</p>
<p>As for that forwarding program (which we’ve been generically referring
to as <code class="docutils literal notranslate"><span class="pre">forward.p4</span></code>), an interesting tangible example is a program
that faithfully implements all the features that a conventional L2/L3
switch supports. Let’s call that program <code class="docutils literal notranslate"><span class="pre">switch.p4</span></code>.<a class="footnote-reference" href="#id4" id="id3">[2]</a> Strangely
enough, that leaves us having re-created the legacy switch we could
have bought from dozens of vendors, but there are two notable
differences: (1) we can control that switch using an SDN controller
via P4Runtime, and (2) we can easily modify that program should we
discover we need a new feature.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Such a program exists (it was written by Barefoot for their
chipset and uses <code class="docutils literal notranslate"><span class="pre">tna.p4</span></code> as its architecture model), but it
is not open source. A roughly equivalent open source variant,
called <code class="docutils literal notranslate"><span class="pre">fabric.p4</span></code>, uses <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code>, but it is more
narrowly written to support Trellis (see Chapter 7) than
serving as a general-purpose L2/L3 data plane.</td></tr>
</tbody>
</table>
<p>To summarize, the overarching goal is to enable the development of
control apps without regard to the specific details of the device
forwarding pipeline. Introducing the P4 architecture model helps meet
this goal, as it enables portability of the same forwarding pipeline
(P4 program) across multiple targets (switching chips) that support
the corresponding architecture model. However, it doesn’t totally
solve the problem because the industry is still free to define
multiple forwarding pipelines. But looking beyond the current
state-of-affairs, having one or more programmable switches opens the
door to programming the control app(s) and the forwarding pipeline in
tandem. When everything is programmable, all the way down to the chip
that forwards packets in the data plane, exposing that programmability
to developers is the ultimate goal. If you have an innovative new
function you want to inject into the network, you write both the
control plane and data plane halves of that function, and turn the
crank on the toolchain to load them into the SDN software stack!</p>
<div class="sidebar">
<p class="first sidebar-title">Is the Complexity Worth It?</p>
<p>At this point you may be wondering if all the complexity being
introduced is worth it, and we haven’t even gotten to the
control plane yet! What we’ve covered so far is complex with
or without SDN. That’s because we’re working at the SW/HW
boundary, and the hardware is designed to forward packets at
rates measured in Terabits-per-second. This complexity use to
be hidden inside proprietary devices. All that SDN has done is
put pressure on the marketplace to open up that space so
others can innovate.</p>
<p>But before anyone can innovate, the first step is to reproduce
what we had running before, except now using open interfaces
and programmable hardware. Even though this chapter uses
<code class="docutils literal notranslate"><span class="pre">forward.p4</span></code> as a hypothetical new data plane function
someone might write, it’s really programs like <code class="docutils literal notranslate"><span class="pre">switch.p4</span></code>
(plus the Switch OS described in the next chapter) that
establish parity with legacy networking gear. Once we have
that in place, we are ready to do something new. But what?</p>
<p class="last">It is not our goal to answer that question with any certainty.
The VNF off-loading and INT examples introduced in Chapter 2
are a start. Chapter 8 goes on to introduce closed-loop
verification and software-defined 5G networks as potential
killer-apps. But history teaches us that killer-apps are
impossible to predict with any accuracy. On the other hand,
history also includes <em>many</em> examples of how opening
closed/fixed-function systems leads to qualitatively new
capabilities.</p>
</div>
</div>
</div>
<div class="section" id="p4-programs">
<h2>4.4 P4 Programs<a class="headerlink" href="#p4-programs" title="Permalink to this headline">¶</a></h2>
<p>Finally, we give a brief overview of the P4 language. The following is
not a comprehensive reference manual for P4. Our more modest goal is
to give a sense of what a P4 program looks like, thereby connecting
all the dots introduced up to this point. We do this by example, that
is, by walking through a P4 program that implements basic IP
forwarding. This example is taken from a P4 Tutorial that you can find
online and try for yourself.</p>
<div class="admonition-further-reading admonition" id="reading-p4">
<p class="first admonition-title">Further Reading</p>
<p class="last"><a class="reference external" href="https://github.com/p4lang/tutorials">P4 Tutorials</a>. P4 Consortium, May 2019.</p>
</div>
<p>To help set some context, think of P4 as similar to the C programming
language. P4 and C share a similar syntax, which makes sense because
both are designed for low-level systems code. Unlike C, however, P4
does not include loops, pointers, or dynamic memory allocation. The
lack of loops makes sense when you remember that we are specifying
what happens in a single pipeline stage. In effect, P4 “unrolls” the
loops we might otherwise need, implementing each iteration in one of a
sequence of control blocks (i.e., stages). In the example program that
follows, you can imagine plugging each code block into the template
shown in the previous section.</p>
<div class="section" id="header-declarations-and-metadata">
<h3>4.4.1 Header Declarations and Metadata<a class="headerlink" href="#header-declarations-and-metadata" title="Permalink to this headline">¶</a></h3>
<p>First comes the protocol header declarations, which for our simple
example includes the Ethernet and IP headers. This is also a place to
define any program-specific metadata we want to associate with the
packet being processed. The example leaves this structure empty, but
<code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code> defines a standard metadata structure for the
architecture as a whole. Although not shown in the following code
block, this standard metadata structure includes such fields as
<code class="docutils literal notranslate"><span class="pre">ingress_port</span></code> (port the packet arrived on), <code class="docutils literal notranslate"><span class="pre">egress_port</span></code> (port
selected to send the packet out on), and <code class="docutils literal notranslate"><span class="pre">drop</span></code> (bit set to indicate
the packet is to be dropped). These fields can be read or written by
the functional blocks that make up the rest of the program. <a class="footnote-reference" href="#id6" id="id5">[3]</a></p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>A quirk of the V1Model is that there are two egress port fields
in the metadata structure. One (<code class="docutils literal notranslate"><span class="pre">egress_port</span></code>) is read-only and
valid only in the egress processing stage. A second
(<code class="docutils literal notranslate"><span class="pre">egress_spec</span></code>), is the field that gets written from the ingress
processing stage to pick the output port. PSA and other
architectures solve this problem by defining different metadata for
the ingress and egress pipelines.</td></tr>
</tbody>
</table>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/***** P4_16 *****/</span>
<span class="cp">#include</span> <span class="cpf">&lt;core.p4&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;v1model.p4&gt;</span><span class="cp"></span>

<span class="k">const</span> <span class="n">bit</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">TYPE_IPV4</span> <span class="o">=</span> <span class="mh">0x800</span><span class="p">;</span>

<span class="cm">/****************************************************</span>
<span class="cm">************* H E A D E R S  ************************</span>
<span class="cm">****************************************************/</span>

<span class="k">typedef</span> <span class="n">bit</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span>  <span class="n">egressSpec_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">bit</span><span class="o">&lt;</span><span class="mi">48</span><span class="o">&gt;</span> <span class="n">macAddr_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">bit</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">ip4Addr_t</span><span class="p">;</span>

<span class="n">header</span> <span class="n">ethernet_t</span> <span class="p">{</span>
    <span class="n">macAddr_t</span> <span class="n">dstAddr</span><span class="p">;</span>
    <span class="n">macAddr_t</span> <span class="n">srcAddr</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span>   <span class="n">etherType</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">header</span> <span class="n">ipv4_t</span> <span class="p">{</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>    <span class="n">version</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>    <span class="n">ihl</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span>    <span class="n">diffserv</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span>   <span class="n">totalLen</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span>   <span class="n">identification</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span>    <span class="n">flags</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;</span>   <span class="n">fragOffset</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span>    <span class="n">ttl</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span>    <span class="n">protocol</span><span class="p">;</span>
    <span class="n">bit</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span>   <span class="n">hdrChecksum</span><span class="p">;</span>
    <span class="n">ip4Addr_t</span> <span class="n">srcAddr</span><span class="p">;</span>
    <span class="n">ip4Addr_t</span> <span class="n">dstAddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">metadata</span> <span class="p">{</span>
   <span class="cm">/* empty */</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">headers</span> <span class="p">{</span>
    <span class="n">ethernet_t</span>   <span class="n">ethernet</span><span class="p">;</span>
    <span class="n">ipv4_t</span>       <span class="n">ipv4</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="parser">
<h3>4.4.2 Parser<a class="headerlink" href="#parser" title="Permalink to this headline">¶</a></h3>
<p>The next block implements the parser. The underlying programming model
for the parser is a state transition diagram, including the built-in
<code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">accept</span></code>, and <code class="docutils literal notranslate"><span class="pre">reject</span></code> states. The programmer adds
other states (<code class="docutils literal notranslate"><span class="pre">parse_ethernet</span></code> and <code class="docutils literal notranslate"><span class="pre">parse_ipv4</span></code> in our example),
plus the state transition logic. For example, the following parser
always transitions from the <code class="docutils literal notranslate"><span class="pre">start</span></code> state to the <code class="docutils literal notranslate"><span class="pre">parse_ethernet</span></code>
state, and if it finds the <code class="docutils literal notranslate"><span class="pre">TYPE_IPV4</span></code> (see the constant definition
in the previous code block) in the <code class="docutils literal notranslate"><span class="pre">etherType</span></code> field of the Ethernet
header, next transitions to the <code class="docutils literal notranslate"><span class="pre">parse_ipv4</span></code> state. As a side-effect
of traversing each state, the corresponding header is extracted from
the packet. The values in these in-memory structures are then
available to the other routines, as we will see below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/****************************************************</span>
<span class="cm">************* P A R S E R  **************************</span>
<span class="cm">****************************************************/</span>

<span class="n">parser</span> <span class="nf">MyParser</span><span class="p">(</span>
                <span class="n">packet_in</span> <span class="n">packet</span><span class="p">,</span>
                <span class="n">out</span> <span class="n">headers</span> <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">standard_metadata_t</span> <span class="n">standard_metadata</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">state</span> <span class="n">start</span> <span class="p">{</span>
        <span class="n">transition</span> <span class="n">parse_ethernet</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">state</span> <span class="n">parse_ethernet</span> <span class="p">{</span>
        <span class="n">packet</span><span class="p">.</span><span class="n">extract</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">ethernet</span><span class="p">);</span>
        <span class="n">transition</span> <span class="n">select</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">ethernet</span><span class="p">.</span><span class="n">etherType</span><span class="p">)</span> <span class="p">{</span>
            <span class="nl">TYPE_IPV4</span><span class="p">:</span> <span class="n">parse_ipv4</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span> <span class="n">accept</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">state</span> <span class="n">parse_ipv4</span> <span class="p">{</span>
        <span class="n">packet</span><span class="p">.</span><span class="n">extract</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">);</span>
        <span class="n">transition</span> <span class="n">accept</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As is the case with all the code blocks in this section, the function
signature for the parser is defined by the architecture model, in this
case, <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code>. We do not comment further on the specific
parameters, except to make the general observation that P4 is
architecture-agnostic. The program you write depends heavily on the
architecture model you include.</p>
</div>
<div class="section" id="ingress-processing">
<h3>4.4.3 Ingress Processing<a class="headerlink" href="#ingress-processing" title="Permalink to this headline">¶</a></h3>
<p>Ingress processing has two parts. The first is checksum verification.<a class="footnote-reference" href="#id8" id="id7">[4]</a> This is minimal in our example; it simply applies the
default. The interesting new feature this example introduces is the
<code class="docutils literal notranslate"><span class="pre">control</span></code> construct, which is effectively P4’s version of a
procedure call. While it is possible for a programmer to also define
“subroutines” as their sense of modularity dictates, at the top level
these control blocks match up one-for-one with the pipeline stages
defined by the logical pipeline model.</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[4]</a></td><td>This is particular to V1Model. PSA doesn’t have an explicit
checksum verification or computation stage of ingress or egress
respectively.</td></tr>
</tbody>
</table>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/****************************************************</span>
<span class="cm">***  C H E C K S U M    V E R I F I C A T I O N   ***</span>
<span class="cm">****************************************************/</span>

<span class="n">control</span> <span class="nf">MyVerifyChecksum</span><span class="p">(</span><span class="n">inout</span> <span class="n">headers</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">apply</span> <span class="p">{</span>  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We now get to the heart of the forwarding algorithm, which is
implemented in the ingress segment of the Match-Action pipeline. What
we find are two <code class="docutils literal notranslate"><span class="pre">actions</span></code> being defined: <code class="docutils literal notranslate"><span class="pre">drop()</span></code> and
<code class="docutils literal notranslate"><span class="pre">ipv4_foward()</span></code>. The second of these two is the interesting one. It
takes a <code class="docutils literal notranslate"><span class="pre">dstAddr</span></code> and an egress port as arguments, assigns the port
to the corresponding field in the standard metadata structure, sets
the <code class="docutils literal notranslate"><span class="pre">srcAddr/dstAddr</span></code> fields in the packet’s ethernet header, and
decrements the ttl field of the IP header. After executing this
action, the headers and metadata associated with this packet contain
enough information to properly carry out the forwarding decision.</p>
<p>But how does that decision get made? This is the purpose of the
<code class="docutils literal notranslate"><span class="pre">table</span></code> construct. The table definition includes a <code class="docutils literal notranslate"><span class="pre">key</span></code> to be
looked up, a possible set of <code class="docutils literal notranslate"><span class="pre">actions</span></code> (<code class="docutils literal notranslate"><span class="pre">ipv4_forward</span></code>, <code class="docutils literal notranslate"><span class="pre">drop</span></code>,
<code class="docutils literal notranslate"><span class="pre">NoAction</span></code>), the size of the table (<code class="docutils literal notranslate"><span class="pre">1024</span></code> entries), and the
default action to take whenever there is no match in the table
(<code class="docutils literal notranslate"><span class="pre">drop</span></code>). The key specification includes both the header field to be
looked up (the <code class="docutils literal notranslate"><span class="pre">dstAddr</span></code> field of the IPv4 header), and the type of
match we want (<code class="docutils literal notranslate"><span class="pre">lpm</span></code> implies Longest Prefix Match). Other possible
match types include <code class="docutils literal notranslate"><span class="pre">exact</span></code> and <code class="docutils literal notranslate"><span class="pre">ternary</span></code>, the latter of which
effectively applies a mask to select which bits in the key to include
in the comparison. <code class="docutils literal notranslate"><span class="pre">lpm</span></code>, <code class="docutils literal notranslate"><span class="pre">exact</span></code> and <code class="docutils literal notranslate"><span class="pre">ternary</span></code> are part of the
core P4 language types, where their definitions can be found in
<code class="docutils literal notranslate"><span class="pre">core.p4</span></code>. P4 architectures can expose additional match types. For
example, PSA also defines <code class="docutils literal notranslate"><span class="pre">range</span></code> and <code class="docutils literal notranslate"><span class="pre">selector</span></code> matches.</p>
<p>The final step of the ingress routine is to “apply” the table we just
defined. This is done only if the parser (or previous pipeline strage)
marked the IP header as valid.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/****************************************************</span>
<span class="cm">******  I N G R E S S   P R O C E S S I N G   *******</span>
<span class="cm">****************************************************/</span>

<span class="n">control</span> <span class="nf">MyIngress</span><span class="p">(</span>
                <span class="n">inout</span> <span class="n">headers</span> <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">standard_metadata_t</span> <span class="n">standard_metadata</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">action</span> <span class="n">drop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mark_to_drop</span><span class="p">(</span><span class="n">standard_metadata</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">action</span> <span class="n">ipv4_forward</span><span class="p">(</span><span class="n">macAddr_t</span> <span class="n">dstAddr</span><span class="p">,</span> <span class="n">egressSpec_t</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">standard_metadata</span><span class="p">.</span><span class="n">egress_spec</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
        <span class="n">hdr</span><span class="p">.</span><span class="n">ethernet</span><span class="p">.</span><span class="n">srcAddr</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">.</span><span class="n">ethernet</span><span class="p">.</span><span class="n">dstAddr</span><span class="p">;</span>
        <span class="n">hdr</span><span class="p">.</span><span class="n">ethernet</span><span class="p">.</span><span class="n">dstAddr</span> <span class="o">=</span> <span class="n">dstAddr</span><span class="p">;</span>
        <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">ttl</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">ttl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">table</span> <span class="n">ipv4_lpm</span> <span class="p">{</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="nl">dstAddr</span><span class="p">:</span> <span class="n">lpm</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">actions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ipv4_forward</span><span class="p">;</span>
            <span class="n">drop</span><span class="p">;</span>
            <span class="n">NoAction</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
       <span class="n">default_action</span> <span class="o">=</span> <span class="n">drop</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">apply</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">ipv4_lpm</span><span class="p">.</span><span class="n">apply</span><span class="p">();</span>
        <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="egress-processing">
<h3>4.4.4 Egress Processing<a class="headerlink" href="#egress-processing" title="Permalink to this headline">¶</a></h3>
<p>Egress processing is a no-op in our simple example, but in general it
is an opportunity to perform actions based on the egress port, which
might not be known during ingress processing (e.g., it might depend on
the traffic manager). For example, replicating a packet to multiple
egress ports for multicast can be done by setting the corresponding
intrinsic metadata in the ingress processing, where the meaning of
such metadata is defined by the architecture. The egress processing
will see as many copies of the same packet as those generated by the
traffic manager. As a second example, if one switch port is expected
to send VLAN-tagged packets, the header must be extended with the
VLAN id. A simple way of dealing with such a scenario is by creating a
table that matches on the <code class="docutils literal notranslate"><span class="pre">egress_port</span></code> of the ingress
metadata. Other examples include doing ingress port pruning for
multicast/broadcast packets and adding a special “CPU header” for
intercepted packets passed up to the control plane.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/****************************************************</span>
<span class="cm">*******  E G R E S S   P R O C E S S I N G   ********</span>
<span class="cm">****************************************************/</span>

<span class="n">control</span> <span class="nf">MyEgress</span><span class="p">(</span>
                <span class="n">inout</span> <span class="n">headers</span> <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">standard_metadata_t</span> <span class="n">standard_metadata</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">apply</span> <span class="p">{</span>  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/****************************************************</span>
<span class="cm">***   C H E C K S U M    C O M P U T A T I O N   ****</span>
<span class="cm">****************************************************/</span>

<span class="n">control</span> <span class="nf">MyComputeChecksum</span><span class="p">(</span>
                <span class="n">inout</span> <span class="n">headers</span>  <span class="n">hdr</span><span class="p">,</span>
                <span class="n">inout</span> <span class="n">metadata</span> <span class="n">meta</span><span class="p">)</span> <span class="p">{</span>

     <span class="n">apply</span> <span class="p">{</span>
        <span class="n">update_checksum</span><span class="p">(</span>
            <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">isValid</span><span class="p">(),</span>
              <span class="p">{</span> <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">version</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">ihl</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">diffserv</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">totalLen</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">identification</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">fragOffset</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">ttl</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">protocol</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">srcAddr</span><span class="p">,</span>
                <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">dstAddr</span> <span class="p">},</span>
            <span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">hdrChecksum</span><span class="p">,</span>
            <span class="n">HashAlgorithm</span><span class="p">.</span><span class="n">csum16</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="deparser">
<h3>4.4.5 Deparser<a class="headerlink" href="#deparser" title="Permalink to this headline">¶</a></h3>
<p>The deparser is typically straightforward. Having potentially
changed various header fields during packet processing, we now have an
opportunity to <code class="docutils literal notranslate"><span class="pre">emit</span></code> the updated header fields. If you change a
header in one of your pipeline stages, you need to remember to emit
it. Only headers that are marketed as valid will be re-serialized into
that packet. There is no need to say anything about the rest of the
packet (i.e., the payload), since by default, all the bytes beyond
where we stopped parsing are included in the outgoing message. The
details of how packets are emitted are specified by the architecture.
For example, TNA supports truncating the payload based on the setting
of a special metadata value consumed by the deparser.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/****************************************************</span>
<span class="cm">*************  D E P A R S E R  *********************</span>
<span class="cm">****************************************************/</span>

<span class="n">control</span> <span class="nf">MyDeparser</span><span class="p">(</span>
                <span class="n">packet_out</span> <span class="n">packet</span><span class="p">,</span>
                <span class="n">in</span> <span class="n">headers</span> <span class="n">hdr</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">apply</span> <span class="p">{</span>
        <span class="n">packet</span><span class="p">.</span><span class="n">emit</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">ethernet</span><span class="p">);</span>
        <span class="n">packet</span><span class="p">.</span><span class="n">emit</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">ipv4</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="switch-definition">
<h3>4.4.6 Switch Definition<a class="headerlink" href="#switch-definition" title="Permalink to this headline">¶</a></h3>
<p>Finally, the P4 program must define the behavior of the switch as a
whole, which is given by the V1Switch package shown below. This set of
elements in this package is defined by <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code>, and consists of
references to all the other routines defined above.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/****************************************************</span>
<span class="cm">*************  S W I T C H  *************************</span>
<span class="cm">****************************************************/</span>

<span class="n">V1Switch</span><span class="p">(</span>
  <span class="n">MyParser</span><span class="p">(),</span>
  <span class="n">MyVerifyChecksum</span><span class="p">(),</span>
  <span class="n">MyIngress</span><span class="p">(),</span>
  <span class="n">MyEgress</span><span class="p">(),</span>
  <span class="n">MyComputeChecksum</span><span class="p">(),</span>
  <span class="n">MyDeparser</span><span class="p">()</span>
<span class="p">)</span> <span class="n">main</span><span class="p">;</span>
</pre></div>
</div>
<p>Keep in mind this example is minimal, but it does serve to illustrate
the essential ideas in a P4 program. What’s hidden by this example is
the interface used by the control plane to inject data into the
routing table; <code class="docutils literal notranslate"><span class="pre">table</span> <span class="pre">ipv4_lpm</span></code> defines the table, but does not
populate it with values. We resolve the mystery of how the control
plane puts values into the table when we discuss P4Runtime in
Chapter 5.</p>
</div>
</div>
<div class="section" id="fixed-function-pipelines">
<h2>4.5  Fixed-Function Pipelines<a class="headerlink" href="#fixed-function-pipelines" title="Permalink to this headline">¶</a></h2>
<p>We now return to fixed-function forwarding pipelines, with the goal of
placing them in the larger ecosystem. Keeping in mind that
fixed-function switching chips still dominate the market, we do not
mean to understate their value or the role they will undoubtedly
continue to play. But they do remove one degree-of-freedom—the ability
to reprogram the data plane—which helps to highlight the the
relationship between all the moving parts introduced in this chapter.</p>
<div class="section" id="of-dpa">
<h3>4.5.1 OF-DPA<a class="headerlink" href="#of-dpa" title="Permalink to this headline">¶</a></h3>
<p>We start with a concrete example: The <em>OpenFlow—Data Plane Abstraction
(OF-DPA)</em> hardware abstraction layer that Broadcom provides for their
switching chips. OF-DPA defines an API that can be used to install
flow rules into the underlying Broadcom ASIC. Technically, an OpenFlow
agent sits on top of OF-DPA (it implements the over-the-wire aspects
of the OpenFlow protocol) and the Broadcom SDK sits below OF-DPA (it
implements the proprietary interface that knows about the low-level
chip details), but OF-DPA is the layer that provides an abstract
representation of the Tomahawk’s fixed forwarding
pipeline. <a class="reference internal" href="#fig-ofdpa1"><span class="std std-numref">Figure 21</span></a> shows the resulting
software stack, where OF-Agent and OF-DPA are open source (the
OF-Agent corresponds to a software module called Indigo, originally
written by BigSwitch), whereas the Broadcom SDK is
proprietary. <a class="reference internal" href="#fig-ofdpa2"><span class="std std-numref">Figure 22</span></a> then depicts what the
OF-DPA pipeline looks like.</p>
<div class="figure align-center" id="id15">
<span id="fig-ofdpa1"></span><a class="reference internal image-reference" href="_images/Slide15.png"><img alt="_images/Slide15.png" src="_images/Slide15.png" style="width: 200px;" /></a>
<p class="caption"><span class="caption-number">Figure 21. </span><span class="caption-text">Software stack for Tomahawk fixed-function forwarding pipeline.</span></p>
</div>
<div class="figure align-center" id="id16">
<span id="fig-ofdpa2"></span><a class="reference internal image-reference" href="_images/ofdpa.png"><img alt="_images/ofdpa.png" src="_images/ofdpa.png" style="width: 650px;" /></a>
<p class="caption"><span class="caption-number">Figure 22. </span><span class="caption-text">Logical fixed-function pipeline defined by OF-DPA.</span></p>
</div>
<p>We do not delve into the details of <a class="reference internal" href="#fig-ofdpa2"><span class="std std-numref">Figure 22</span></a>,
but the reader will recognize tables for several well-known protocols.
For our purposes, what is instructive is to see how OF-DPA maps onto
its programmable pipeline counterparts. In the programmable case, it’s
not until you add a program like <code class="docutils literal notranslate"><span class="pre">switch.p4</span></code> that you get something
roughly equivalent OF-DPA. That is, <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code> defines the available
stages (control blocks). It’s not until you add <code class="docutils literal notranslate"><span class="pre">switch.p4</span></code> that you
have the functionality that runs in those stages.</p>
<p>With this relationship in mind, we might want to incorporate both
programmable and fixed-function switches in a single network and
running a common SDN software stack. This can be accomplished by
hiding both types of chips behind the <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code> (or similar)
architecture model, and letting the P4 compiler output the backend
code understood by their respective SDKs. Obviously this scenario
doesn’t work for an arbitrary P4 program that wants to do something
that the Tomahawk chip doesn’t support, but it will work for standard
L2/L3 switch behavior.</p>
</div>
<div class="section" id="sai">
<h3>4.5.2 SAI<a class="headerlink" href="#sai" title="Permalink to this headline">¶</a></h3>
<p>Just as we saw both vendor-defined and community-defined architecture
models (TNA and V1Model, respectively), there are also vendor-defined
and community-defined logical fixed-function pipelines. OF-DPA is the
former, and the <em>Switch Abstraction Interface (SAI)</em> is an example of
the latter. Because SAI has to work across a range of switches—and
forwarding pipelines—it necessarily focuses on the subset of
functionality all vendors can agree on, the least common denominator,
so to speak.</p>
<p>SAI includes both a configuration interface and a control interface,
where its the control interface that’s most relevant to this section
because it abstracts the forwarding pipeline. On the other hand, there
is little value in looking at yet another forwarding pipeline, so we
refer the interested reader to the SAI specification for more details.</p>
<div class="admonition-further-reading admonition" id="reading-sai">
<p class="first admonition-title">Further Reading</p>
<p class="last"><a class="reference external" href="https://github.com/opencomputeproject/SAI/blob/master/doc/behavioral%20model/pipeline_v6.pdf">SAI Pipeline Behavioral Model.</a>
Open Compute Project.</p>
</div>
<p>We revisit the configuration API in the next chapter.</p>
</div>
</div>
<div class="section" id="comparison">
<h2>4.6 Comparison<a class="headerlink" href="#comparison" title="Permalink to this headline">¶</a></h2>
<p>This discussion about logical pipelines and their relationship to P4
programs is subtle, and worth restating. On the one hand, there is
obvious value in having an abstract representation of a physical
pipeline, as introduced as a general concept in <a class="reference internal" href="#fig-logical"><span class="std std-numref">Figure 18</span></a>. When used in this way, a logical pipeline is an
example of the tried-and-true idea of introducing a hardware
abstraction layer. In our case, it helps with control plane
portability.  OF-DPA is a specific example of a hardware abstraction
layer for Broadcom’s fixed-function switching chips.</p>
<p>On the other hand, P4 provides a programming model, with architectures
like <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code> and <code class="docutils literal notranslate"><span class="pre">tna.p4</span></code> adding detail to P4’s general
language constructs (e.g., <code class="docutils literal notranslate"><span class="pre">control</span></code>, <code class="docutils literal notranslate"><span class="pre">table</span></code>, <code class="docutils literal notranslate"><span class="pre">parser</span></code>). These
architecture models are, in effect, a language-based abstraction of a
generic forwarding device, which can be fully-resolved into a logical
pipeline by adding a particular P4 program like <code class="docutils literal notranslate"><span class="pre">switch.p4</span></code>. P4
architecture models don’t define pipelines of match-action tables, but
they instead define the building blocks (including signatures) that
can be used by a P4 developer to define a pipeline, whether logical or
physical. In a sense, then, P4 architectures are equivalent to a
traditional switch SDK, as illustrated by the five side-by-side
examples in <a class="reference internal" href="#fig-compare"><span class="std std-numref">Figure 23</span></a>.</p>
<div class="figure align-center" id="id17">
<span id="fig-compare"></span><a class="reference internal image-reference" href="_images/Slide23.png"><img alt="_images/Slide23.png" src="_images/Slide23.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-number">Figure 23. </span><span class="caption-text">Five example Pipeline/SDK/ASIC stacks. The two leftmost stacks,
plus the fourth stack, exist today; the middle stack is
hypothetical; and the rightmost stack is a work-in-progress.</span></p>
</div>
<p>Each example in <a class="reference internal" href="#fig-compare"><span class="std std-numref">Figure 23</span></a> consists of three
layers: a switching chip ASIC, a vendor-specific SDK for programming
the ASIC, and a definition of the forwarding pipeline. By providing a
programmatic interface, the SDKs in the middle layer effectively
abstract the underlying hardware. They are either conventional (e.g.,
the Broadcom SDK shown in the second and fourth examples) or as just
pointed out, logically corresponds to a P4 architecture model paired
with an ASIC-specific P4 compiler.  The topmost layer in all five
examples defines a logical pipeline that can subsequently be
controlled using a control interface like OpenFlow or P4Runtime (not
shown). The five examples differ based on whether the pipeline is
defined by a P4 program or through some other means (e.g., the OF-DPA
specification).</p>
<p>Note that only those configurations with a P4-defined logical pipeline
at the top of the stack (i.e., first, third, fifth examples) can be
controlled using P4Runtime. This is for the pragmatic reason that the
P4Runtime interface is auto-generated from this P4 program using the
tooling described in the next Chapter.</p>
<p>The two leftmost examples exist today, and represent the canonical
layers for programmable and fixed-function ASICs, respectively. The
middle example is purely hypothetical, but it illustrate that it is
possible to define a P4-based stack even for a fixed-function pipeline
(and by implication, control it using P4Runtime). The fourth example
also exists today, and is how Broadcom ASICs conform to the
SAI-defined logical pipeline. Finally, the rightmost example projects
into the future, when SAI is extended to support P4 programmability
and runs on multiple ASICs.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="stratum.html" class="btn btn-neutral float-right" title="Chapter 5: Switch OS" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="arch.html" class="btn btn-neutral float-left" title="Chapter 3: Basic Architecture" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
