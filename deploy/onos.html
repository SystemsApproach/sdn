

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapter 6: Network OS &mdash; Software-Defined Networks: A Systems Approach Version 0.3-dev documentation</title>
  

  
  
    <link rel="shortcut icon" href="static/bridge.ico"/>
  
  
  

  
  <script type="text/javascript" src="static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
        <script type="text/javascript" src="static/jquery.js"></script>
        <script type="text/javascript" src="static/underscore.js"></script>
        <script type="text/javascript" src="static/doctools.js"></script>
        <script type="text/javascript" src="static/language_data.js"></script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Chapter 7: Leaf-Spine Fabric" href="trellis.html" />
    <link rel="prev" title="Chapter 5: Switch OS" href="stratum.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Software-Defined Networks: A Systems Approach
          

          
          </a>

          
            
            
              <div class="version">
                Version 0.3-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Chapter 1:  Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="uses.html">Chapter 2:  Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="arch.html">Chapter 3:  Basic Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="switch.html">Chapter 4:  White-Box Switches</a></li>
<li class="toctree-l1"><a class="reference internal" href="stratum.html">Chapter 5:  Switch OS</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chapter 6:  Network OS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#onos-architecture">6.1 ONOS Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="#distributed-core">6.2 Distributed Core</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#atomix-primitives">6.2.1 Atomix Primitives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#services">6.2.2 Services</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#northbound-interface">6.3 Northbound Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#southbound-interface">6.4 Southbound Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#provider-plugins">6.4.1 Provider Plugins</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-drivers">6.4.2 Device Drivers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#scalable-performance">6.5 Scalable Performance</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trellis.html">Chapter 7:  Leaf-Spine Fabric</a></li>
<li class="toctree-l1"><a class="reference internal" href="future.html">Chapter 8:  Future of SDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">Hands-on Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html">About The Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">About The Authors</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Software-Defined Networks: A Systems Approach</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Chapter 6:  Network OS</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/onos.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="trellis.html" class="btn btn-neutral float-right" title="Chapter 7: Leaf-Spine Fabric" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="stratum.html" class="btn btn-neutral float-left" title="Chapter 5: Switch OS" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="chapter-6-network-os">
<h1>Chapter 6:  Network OS<a class="headerlink" href="#chapter-6-network-os" title="Permalink to this headline">¶</a></h1>
<p>We are now ready to move from a single switch with purely local state,
to the global, network-wide view maintained by a Network Operating
System. The best way to think about a NOS is that it is like any other
horizontally scalable cloud application. It consists of a collection
of loosely coupled subsystems—as is often associated with a
micro-service architecture—including a scalable and highly available
key/value store.</p>
<p>This chapter describes the overall structure of a NOS using ONOS as a
reference implementation. The focus is on the core abstractions that
have emerged from experience implementing a wide range of control
applications on top of ONOS, and using ONOS to manage an equally wide
range of network devices. This chapter also discusses the critically
important issues of scalable performance and high availability.</p>
<div class="section" id="onos-architecture">
<h2>6.1 ONOS Architecture<a class="headerlink" href="#onos-architecture" title="Permalink to this headline">¶</a></h2>
<p>The overall architecture for ONOS is shown in <a class="reference internal" href="#fig-onos"><span class="std std-numref">Figure 27</span></a>. It consists of three main layers:</p>
<ol class="arabic simple">
<li>A collection of Northbound Interfaces (NBI) that applications use to
stay informed about the network state (e.g. traverse topology graph,
intercept network packets) and also to control the network data plane
(e.g. program flow objectives via FlowObjective API introduced in
Chapter 3).</li>
<li>A Distributed Core that is responsible for managing network state
and notifying applications about relevant changes in that
state. Internal to the core is a scalable key/value store called
Atomix.</li>
<li>A Southbound Interface (SBI) constructed from a collection plugins
including shared protocol libraries and device-specific drivers.</li>
</ol>
<div class="figure align-center" id="id5">
<span id="fig-onos"></span><a class="reference internal image-reference" href="_images/Slide26.png"><img alt="_images/Slide26.png" src="_images/Slide26.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-number">Figure 27. </span><span class="caption-text">Three-layer architecture of ONOS, hosting a set of control
applications.</span></p>
</div>
<p>As <a class="reference internal" href="#fig-onos"><span class="std std-numref">Figure 27</span></a> suggests, the design is highly
modular, with a given deployment configured to include the subset of
modules it requires. We delay a discussion about the exact form for
the modularity (e.g., Karaf, Kubernetes) until the concluding section,
where we take up the issue of scalability. Until then, the focus is
on the functional organization of ONOS.</p>
<p>There are three other things to note about <a class="reference internal" href="#fig-onos"><span class="std std-numref">Figure 27</span></a> before we get into the details about each layer. The first
is the breadth of the NBI. If you think of ONOS as an operating
system, this makes sense: All access to the underlying hardware,
whether by a control program or a human operator, is mediated by
ONOS. This means the union of all northbound APIs must be sufficient
to configure, operate, and control the network. For example, the NBI
includes gNMI and gNOI for configuration and operations,
respectively. It also means the NBI includes a Topology API that
Control Applications use to learn about changes in the underlying
network state (e.g., ports coming up and down), along with the
FlowObjective API used to control the underlying switches.</p>
<p>As an aside, while we generally characterize the applications that run
on top of a Network OS as implementing the network control plane,
there are actually a wide assortment of apps running on ONOS,
implementing everything from a GUI that can be used to monitor the
state of the network, to a traditional CLI that operators can use to
issue directives.</p>
<p>Among the applications sitting on top of ONOS is a zero-touch
management plane that provisions new hardware added to the network,
making sure the right software, certificates, configuration
parameters, and pipeline definition are installed. This example is
illustrated in <a class="reference internal" href="#fig-ztp"><span class="std std-numref">Figure 28</span></a>, where one takeaway is
that ONOS does not have a fixed NBI: there are potentially multiple
layers of applications and services running on ONOS, each providing
some value on top of the applications and services below it. Declaring
zero-touch provisioning to be <em>in</em> ONOS versus <em>on</em> ONOS is an
arbitrary statement, which points to an important way in which ONOS is
<em>not</em> like a conventional operating system: There is no
syscall-equivalent interface demarking the boundary between a
privileged kernel and multiple user domains. In other words, ONOS
currently operates in a single trust domain.</p>
<div class="figure align-center" id="id6">
<span id="fig-ztp"></span><a class="reference internal image-reference" href="_images/Slide28.png"><img alt="_images/Slide28.png" src="_images/Slide28.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Figure 28. </span><span class="caption-text">Example of a Zero-Touch Provisioning (ZTP) application taking a
“role spec” for a switch being installed as input, with ONOS
provisioning the switch accordingly.</span></p>
</div>
<p>The second thing to note about <a class="reference internal" href="#fig-onos"><span class="std std-numref">Figure 27</span></a> is that
ONOS maps an abstract specification of behavior the control
application wants to impose on the network onto the concrete
instructions that need to be communicated to each switch in the
network. Applications can select from a variety of means of how to
affect the network operation. Some applications use high-level
<em>Intents</em>, which are network-wide, topology-independent programming
constructs. Others that require finer-grained control use Flow
Objectives, which are device-centric programming constructs. Flow
Objectives are much like Flow Rules, except they are
pipeline-independent. Applications use them to control both
fixed-function and programmable pipelines. As highlighted in
<a class="reference internal" href="#fig-layers"><span class="std std-numref">Figure 29</span></a>, doing this job in the face of varied
forwarding pipelines is a complexity ONOS is explicitly designed to
address.</p>
<div class="figure align-center" id="id7">
<span id="fig-layers"></span><a class="reference internal image-reference" href="_images/Slide27.png"><img alt="_images/Slide27.png" src="_images/Slide27.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Figure 29. </span><span class="caption-text">ONOS manages the mapping of an abstract specification of
network-wide behavior to a collection of per-device instructions.</span></p>
</div>
<p>The third thing to notice about <a class="reference internal" href="#fig-onos"><span class="std std-numref">Figure 27</span></a> is that
information flows both “down” and “up” through ONOS. It’s easy to
focus on applications using the ONOS NBI to control the network, but
it is also the case that the southbound plugins pass information about
the underlying network up to the ONOS core. This includes intercepting
packets, discovering devices and their ports, reporting link quality,
and so on. These interactions between the ONOS core and the network
devices are handled by a set of adaptors (e.g., OpenFlow, P4Runtime),
which hide the details of communicating with the devices, thereby
insulating the ONOS core and the applications running on top of it
from the diversity of network devices. For example, ONOS is being used
to control black-box switches, white-box switches, optical devices,
and cellular base stations.</p>
</div>
<div class="section" id="distributed-core">
<h2>6.2 Distributed Core<a class="headerlink" href="#distributed-core" title="Permalink to this headline">¶</a></h2>
<p>The ONOS core is comprised of a number of subsystems, each responsible
for a particular aspect of network state (e.g. topology, host
tracking, packet intercept, flow programming). Each subsystem
maintains its own <em>service abstraction</em>, where its implementation is
responsible for propagating the state throughout the cluster.</p>
<p>Many ONOS services are built using distributed tables (maps), which
are in turn implemented using a distributed key/value store. The store
itself will be familiar to anyone that has looked at how modern cloud
services are designed—it scales across a distributed set of servers,
and implements the Raft consensus algorithm to achieve fault-tolerance
in the event of failures. If you are unfamiliar with Raft, Diego
Ongaro and John Ousterhoust have written an excellent introduction.</p>
<div class="admonition-further-reading admonition" id="reading-p4">
<p class="first admonition-title">Further Reading</p>
<ol class="last upperalpha simple" start="4">
<li>Ongaro and J. Ousterhout. <a class="reference external" href="https://raft.github.io/">The Raft Consensus Algorithm</a>.</li>
</ol>
</div>
<p>ONOS uses Atomix as its store, where Atomix goes beyond the core Raft
algorithm to provide a rich set of programming primitives that ONOS
uses to manage the distributed state and make it easy for control apps
to access.</p>
<p>This is a common design paradigm, which results in a system that is
both scalable (runs on enough virtualized instances to handle the
request workload) and highly available (run on enough instances to
continue offering service in the face of failure). What’s unique about
ONOS—or any Network OS, for that matter—is the set of maps it defines:
the semantics of the keys it stores and the types of the values
associated with those keys. It is this data model that makes a Network
OS a Network OS (and not a ride-share application or a social
network).  This section mostly focuses on this set of data models and
the corresponding services built around them, although we start with a
brief introduction to the primitives that Atomix supports.</p>
<div class="section" id="atomix-primitives">
<h3>6.2.1 Atomix Primitives<a class="headerlink" href="#atomix-primitives" title="Permalink to this headline">¶</a></h3>
<p>The preceding discussion introduced Atomix as a key/value store, which
it is, but it is also accurate to describe Atomix as a general tool
for building distributed systems. It is a Java-based system that
includes support for:</p>
<ul class="simple">
<li>Distributed data structures, including maps, sets, trees, and counters.</li>
<li>Distributed communication, including direct messaging and publish/subscribe.</li>
<li>Distributed coordination, including locks, leader elections, and barriers.</li>
<li>Managing group membership.</li>
</ul>
<p>For example, Atomix includes <code class="docutils literal notranslate"><span class="pre">AtomicMap</span></code> and <code class="docutils literal notranslate"><span class="pre">DistributedMap</span></code>
primitives. Both extend Java’s <code class="docutils literal notranslate"><span class="pre">Map</span></code> utility with additional
methods. In the case of <code class="docutils literal notranslate"><span class="pre">AtomicMap</span></code>, the primitive performs atomic
updates using optimistic locks, such that all operations are
guaranteed to be atomic (and each value in a map has a monotonically
increasing version number). In contrast, the <code class="docutils literal notranslate"><span class="pre">DistributedMap</span></code>
primitive supports eventual consistency rather than guarantee
consistency. Both primitives support event-based notifications of
changes to the corresponding map. Clients can listen for
inserted/updated/removed entries by registering event listeners on a
map.</p>
<p>Maps are the workhorse primitive used by ONOS, as we will see in the
next subsection. We conclude this section by looking at another role
that Atomix plays in ONOS: coordinating all the ONOS instances.<a class="footnote-reference" href="#id2" id="id1">[1]</a>
There are two aspects to this coordination.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For the purpose of this discussion, assume ONOS is packaged as
a whole, and then scaled across multiple virtualized instances.
An alternative partitioning of ONOS functionality into
independently scaled microservices is discussed in Section 6.5.</td></tr>
</tbody>
</table>
<p>First, as a horizontally scalable service, the number of ONOS
instances running at any given time depends on the workload and the
level of replication needed to guarantee availability in the face of
failures. The Atomix <em>group membership</em> primitive is used to determine
the set of available instances, making it possible to detect new
instances that have been spun up and existing instances that have
failed. (Note that the set of ONOS instances are distinct from the set
of Atomix instances, with both able to scale independently. This and
the next paragraph are focused on the ONOS instances.)</p>
<p>Second, the primary job of each instance is to monitor and control a
subset of the physical switches in the network. The approach ONOS
takes is to elect a master instance for each switch, where only the
master issues (writes) control instructions to a given switch. All the
instances are able to monitor (read) switch state. The instances then
use the Atomix <em>leader-election</em> primitive to determine the master for
each switch. Should an ONOS instance fail, the same primitive is used
to elect a new master for the switches. The same approach is applied
when a new switch comes on-line.</p>
</div>
<div class="section" id="services">
<h3>6.2.2 Services<a class="headerlink" href="#services" title="Permalink to this headline">¶</a></h3>
<p>ONOS builds on Atomix by defining a core set of tables (maps), which
are in turn packaged as a collection of <em>services</em> available to
control applications (and other services). A table and a service are
two ways of looking at the same things: one is a collection of
key/value pairs and the other is the interface through which
applications and other services interact with those pairs.
<a class="reference internal" href="#fig-services1"><span class="std std-numref">Figure 30</span></a> depicts the respective layers,
where the middle three components—Topology, Link, and Device—are
example ONOS services.</p>
<div class="figure align-center" id="id8">
<span id="fig-services1"></span><a class="reference internal image-reference" href="_images/Slide29.png"><img alt="_images/Slide29.png" src="_images/Slide29.png" style="width: 350px;" /></a>
<p class="caption"><span class="caption-number">Figure 30. </span><span class="caption-text">ONOS provides a set of services, such as the Topology, Device, and
Link Services, on top of a corresponding table (Map) implemented
in Atomix.</span></p>
</div>
<p>Note that the Topology Service in <a class="reference internal" href="#fig-services1"><span class="std std-numref">Figure 30</span></a>
does not have an associated map, but instead indirectly accesses the
maps defined by the Link and Device Services. The Topology Service
caches the resulting network graph in memory, which gives applications
a low-latency, read-only way access to network state. The Topology
Service also computes a spanning tree of the graph to ensure that all
applications see the same broadcast tree.</p>
<p>As a whole, ONOS defines an inter-connected graph of services, with
<a class="reference internal" href="#fig-services1"><span class="std std-numref">Figure 30</span></a> showing just a small
subgraph. <a class="reference internal" href="#fig-services2"><span class="std std-numref">Figure 31</span></a> expands on that view to
illustrate some other aspects of the ONOS core, this time simplified
to show the Atomix maps as an attribute of some (but not all) of the
services. There are several things of note about this example.</p>
<div class="figure align-center" id="id9">
<span id="fig-services2"></span><a class="reference internal image-reference" href="_images/Slide33.png"><img alt="_images/Slide33.png" src="_images/Slide33.png" style="width: 550px;" /></a>
<p class="caption"><span class="caption-number">Figure 31. </span><span class="caption-text">Dependency graph of services (some with their own key/value maps)
involved in building a Path Service.</span></p>
</div>
<p>First, the Path Service, which applications can query to learn
end-to-end paths between host pairs, depends on both the Topology
Service (which tracks the network graph) and a Host Service (which
tracks the hosts connected to the network). Note that arrow
directionality implies dependency, but as we saw in <a class="reference internal" href="#fig-services2"><span class="std std-numref">Figure 31</span></a>, information flows in both directions.</p>
<p>Second, the Host Service has both a north-bound and a south-bound
interface. The Path Service uses its north-bound interface to read
host-related information, while the Host Location Provider uses its
south-bound interface to write host-related information. The Host
Service itself is little more than a wrapper around the Atomix Map
that stores information about hosts. We return to the <em>Provider</em>
abstraction in Section 6.4, but in a nutshell, they are modules that
interact with the underlying network devices.</p>
<p>Third, the Host Location Provider snoops network traffic—for example,
intercepting ARP, NDP, and DHCP packets—to learn about hosts connected
to the network, which it then provides to the Host Service. The Host
Location Provider, in turn, depends on a Packet Service to help it
intercept those packets. The Packet Service defines a
device-independent means for other ONOS services to instruct the
underlying switches to capture and forward select packets to the
control plane. ONOS services can also use the Packet Service to inject
packets into the data plane.</p>
<p>Finally, while the service graph depicted in <a class="reference internal" href="#fig-services2"><span class="std std-numref">Figure 31</span></a> is designed to discover the network topology, there
are many scenarios where the topology is fixed, and known <em>a
priori</em>. This often happens when the control plane is tailored for a
particular topology, as is the case for the leaf-spine topology
discussed throughout this book. For such scenarios, the Topology
Service accepts configuration instructions from a control application
(or high-level service) sitting above it in the dependency graph.<a class="footnote-reference" href="#id4" id="id3">[2]</a>
ONOS includes such a configuration service, called <em>Network Config</em>,
as depicted in <a class="reference internal" href="#fig-services3"><span class="std std-numref">Figure 32</span></a>. Network Config, in
turn, accepts configuration directives from either a human operator or
an automated orchestrator, such as the example ZTP control application
from <a class="reference internal" href="#fig-ztp"><span class="std std-numref">Figure 28</span></a>.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>The Topology Service still collects ground-truth information
from the underlying network, verifies that it matches the
configuration directives passed in from above, and notifies the
Network Config Service when there is a discrepancy.</td></tr>
</tbody>
</table>
<div class="figure align-center" id="id10">
<span id="fig-services3"></span><a class="reference internal image-reference" href="_images/Slide34.png"><img alt="_images/Slide34.png" src="_images/Slide34.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-number">Figure 32. </span><span class="caption-text">Network Config Service, supporting both provisioning applications
and human operators.</span></p>
</div>
<p>The sequence of examples we just walked through (<a class="reference internal" href="#fig-services1"><span class="std std-numref">Figures 30</span></a>, <a class="reference internal" href="#fig-services2"><span class="std std-numref">31</span></a>, and <a class="reference internal" href="#fig-services3"><span class="std std-numref">32</span></a>) illustrate the basics of how ONOS is built from
parts. For completeness, the following gives a summary of the most
commonly used ONOS services:</p>
<blockquote>
<div><p><strong>Host:</strong> Records end systems (machine or virtual machine) connected
to the network. Populated by one or more host discovery apps,
generally by intercepting ARP, NDP, or DHCP packets.</p>
<p><strong>Device:</strong> Records infrastructure device-specific information
(switches, ROADMs, etc.), including ports. Populated by one or more
device discovery apps.</p>
<p><strong>Link:</strong> Records attributes of links connecting pairs of
infrastructure devices/ports. Populated by one or more link
discovery apps (e.g., by emitting an intercepting LLDP packets).</p>
<p><strong>Topology:</strong> Represents the network as a whole using a graph
abstraction. It is built on top of the Device and Link services and
provides a coherent graph comprised of infrastructure devices as
vertices and infrastructure links as edges. The graph converges on the
network topology using eventual consistency approach as events about
device and link inventory are received.</p>
<p><strong>Mastership:</strong> Runs leadership contests (using Atomix leader-election
primitive) to elect which ONOS instance in the cluster should be the
master for each infrastructure device. In cases when an ONOS instance
fails (e.g., server power failure), it makes sure a new master is
elected as soon as possible for all devices left without one.</p>
<p><strong>Cluster:</strong> Manages ONOS cluster configuration. It provides
information about the Atomix cluster nodes as well as about all peer
ONOS nodes. Atomix nodes form the actual cluster that is the basis
for consensus, while the ONOS nodes are effectively mere clients
used to scale control logic and I/O to network devices. Entries set
by ONOS using Atomix membership primitive.</p>
<p><strong>Network Config:</strong> Prescribes meta-information about the network,
such as devices and their ports, hosts, links, etc. Provides outside
information about the network and how the network should be treated by
ONOS core and applications. Set by orchestrator apps, the ZTP control
application, or manually by an operator.</p>
<p><strong>Component Config:</strong> Manages configuration parameters for various
software components in the ONOS core and applications. Such
parameters (i.e. how to treat foreign flow rules, address or DHCP
server, polling frequency, and so on) allow for tailoring the
behavior of the software. Set by the operator according to the needs of
the deployment.</p>
<p><strong>Packet:</strong> Allows the core services and applications to intercept
packets (packet in) and to emit packets back into the network. This
is the basis for most of the host and link discovery methods (e.g.,
ARP, DHCP, LLDP).</p>
</div></blockquote>
<p>The above services are used by nearly every application because they
offer information about the network devices and their topology. There
are, however, many more services, including ones that allow
applications to program the behavior of the network using different
constructs and different levels of abstraction. We discuss some of
these in more depth in the next section, but for now we note that they
include:</p>
<blockquote>
<div><p><strong>Route:</strong> Defines a prefix to nexthop mapping. Set either by a
control app or manually configured by an operator.</p>
<p><strong>Mcast:</strong> Defines group IP, source and sink locations. Set by a
control app or manually configured by an operator.</p>
<p><strong>Group:</strong> Aggregates ports or actions in a device. Flow entries can
point to a defined group to allow sophisticated means of forwarding,
such as load-balancing between ports in a group, failover among
ports in a group, or multicast to all ports specified in a group.  A
group can also be used for aggregating common actions of different
flows, so that in some scenarios only one group entry is required to
be modified for all the referencing flow entries instead of having
to modify all of them.</p>
<p><strong>Meter:</strong> Expresses a rate-limit to enforce a quality of service
for select network traffic handled by a device.</p>
<p><strong>Flow Rule:</strong> Provides a device-centric, match/action pair for
programming the data-plane forwarding behavior of a device. It
requires that flow rule entries be composed in accordance with the
device’s table pipeline structure and capabilities.</p>
<p><strong>Flow Objective:</strong> Provides a device-centric abstraction for
programming the forwarding behavior of a device in a
pipeline-agnostic manner. It relies on the Pipeliner subsystem (see
next section) to implement the mapping between table-agnostic flow
objectives and table-specific flow rules or groups.</p>
<p><strong>Intent:</strong> Provides a topology-agnostic way to establish flows
across the network. High-level specifications, call <em>intents</em>,
indicate various hints and constraints for the end-to-endpath,
including the type of traffic and the source and destination hosts,
or ingress and egress ports to request connectivity. The service
provisions this connectivity over the appropriate paths and then
continuously monitors the network, changing the paths over time to
continue meeting the objectives prescribed by the intent in the face
of varying network conditions.</p>
</div></blockquote>
<p>Each of the above services comprises its own distributed store and
notification capabilities. Individual applications are free to extend
this set with their own services and to back their implementations
with their own distributed stores. This is why ONOS provides
applications with direct access to Atomix primitives, such as
<code class="docutils literal notranslate"><span class="pre">AtomicMaps</span></code> and <code class="docutils literal notranslate"><span class="pre">DistributedMaps</span></code>. We will see examples of such
extensions in the next Chapter when we take a closer look at Trellis.</p>
</div>
</div>
<div class="section" id="northbound-interface">
<h2>6.3 Northbound Interface<a class="headerlink" href="#northbound-interface" title="Permalink to this headline">¶</a></h2>
<p>The ONOS NBI has multiple parts. First, for every service included in
a given configuration of ONOS, there is a corresponding API. For
example, the “Topology” interface shown in <a class="reference internal" href="#fig-onos"><span class="std std-numref">Figure 27</span></a> is exactly the API offered by the Topology Service shown
in <a class="reference internal" href="#fig-services1"><span class="std std-numref">Figure 30</span></a>. Second, because ONOS permits
applications to define and use their own Atomix tables, it is fair to
consider the Atomix programmatic interface as another part of the ONOS
NBI. Third, the ONOS NBI includes gNMI and gNOI. These are
standardized interfaces, defined independent of ONOS, but supported as
part of the ONOS NBI. Note that the implementation sitting behind gNMI
and gNOI are also ONOS services wrapped around Atomix maps. Finally,
and most interestingly, ONOS offers a set of interfaces for
controlling the underlying switches. <a class="reference internal" href="#fig-onos"><span class="std std-numref">Figure 27</span></a>
depicts two: Flow Rules and Flow Objectives. The first is borrowed
from OpenFlow, and hence, is pipeline-aware. The second is
pipeline-agnostic, and the focus of the rest of this section.</p>
<p>There are three types of flow objectives: <em>Filtering</em>, <em>Forwarding</em>,
and <em>Next</em>. Filtering objectives determine whether or not traffic
should be permitted to enter the pipeline, based on a traffic
<em>Selector</em>. Forwarding objectives determine what traffic is to be
allowed to egress the pipeline, generally by matching select fields in
the packet with a forwarding table. Next objectives indicate what kind
of <em>Treatment</em> the traffic should receive, such as how the header is
to be rewritten. If this sounds like an abstract three-stage pipeline:</p>
<p class="centered">
<strong>Filtering → Forwarding → Next</strong></p><p>then you understand the idea behind Flow Objectives. For example, the
Filter objective (stage) might specify that packets matching a
particular MAC address, VLAN tag, and IP address be allowed to enter
the pipeline; the corresponding Forwarding objective (stage) then
looks up the IP address in a routing table; and finally the Next
objective (stage) rewrites the headers as necessary and assigns the
packet to an output port. All three stages, of course, are agnostic as
to exactly what combination of tables in the underlying switch are
used to implement the corresponding sequence of match/action pairs.</p>
<p>The challenge is to map these pipeline-agnostic objectives onto the
corresponding pipeline-dependent rules. In ONOS, this mapping is
managed by the Flow Objective Service, as depicted in <a class="reference internal" href="#fig-flowobj"><span class="std std-numref">Figure
33</span></a>. For simplicity, the example focuses on the selector
(match) specified by a Filtering objective, where the key is to
express the fact that you want to select a particular input port, MAC
address, VLAN tag, and IP address combination, without regard for
the exact sequence of pipeline tables that implement that combination.</p>
<div class="figure align-center" id="id11">
<span id="fig-flowobj"></span><a class="reference internal image-reference" href="_images/Slide39.png"><img alt="_images/Slide39.png" src="_images/Slide39.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Figure 33. </span><span class="caption-text">Flow Objective Service manages the mapping of pipeline-agnostic
objectives onto pipeline-specific rules.</span></p>
</div>
<p>Internally, the Flow Objective Service is organized as a collection of
device-specific handlers, each of which is implemented using the ONOS
device driver mechanism. The device driver behavior that abstracts the
implementation of how flow objective directives should map to flow
rule operations is called a <em>Pipeliner</em>.  <a class="reference internal" href="#fig-flowobj"><span class="std std-numref">Figure 33</span></a> shows Pipeliners for two example switch pipelines.</p>
<p>Pipeliners are able to map flow objectives onto both flow rules (in
the case of fixed-function pipelines) and P4-programmed pipelines. The
example given in <a class="reference internal" href="#fig-flowobj"><span class="std std-numref">Figure 33</span></a> shows the former
case, which includes a mapping to OpenFlow 1.3. In the latter case,
Pipeliner leverages <em>Pipeconf</em>, a structure that maintains
associations among the following elements:</p>
<ol class="arabic simple">
<li>A model of the pipeline for each target switch.</li>
<li>A target-specific driver needed to to deploy flow instructions to the switch.</li>
<li>A pipeline-specific translator to map flow objectives into the target pipeline.</li>
</ol>
<p>Pipeconf maintains these bindings using information extracted from the
<code class="docutils literal notranslate"><span class="pre">.p4info</span></code> file output by the P4 compiler, as described in Section
5.2.</p>
<p>Today, the “model” identified in (1) is ONOS-defined, meaning the
end-to-end workflow for a developer involves being aware of both a P4
architecture model (e.g., <code class="docutils literal notranslate"><span class="pre">v1model.p4</span></code>) when programming the data
plane and this ONOS model when programming the control plane using
flow objectives. Eventually, these various layers of pipeline models
will be unified, and in all likelihood, specified in P4.</p>
<p>Programmatically, flow objectives are a data structure, packaged with
associated constructor routines. The control application builds a list
of objectives and passes them to ONOS to be executed. The following
code example shows flow objectives being constructed to specify an
end-to-end flow through the network. The process of applying them to
the underlying devices is done elsewhere, and not included in the
example.</p>
<div class="code java highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">void</span> <span class="n">createFlow</span><span class="p">(</span><span class="n">TrafficSelector</span> <span class="n">originalSelector</span><span class="p">,</span>
                   <span class="n">TrafficTreatment</span> <span class="n">originalTreatment</span><span class="p">,</span>
                   <span class="n">ConnectPoint</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">ConnectPoint</span> <span class="n">egress</span><span class="p">,</span>
                   <span class="nb">int</span> <span class="n">priority</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">applyTreatment</span><span class="p">,</span>
                   <span class="n">List</span><span class="o">&lt;</span><span class="n">Objective</span><span class="o">&gt;</span> <span class="n">objectives</span><span class="p">,</span>
                   <span class="n">List</span><span class="o">&lt;</span><span class="n">DeviceId</span><span class="o">&gt;</span> <span class="n">devices</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TrafficSelector</span> <span class="n">selector</span> <span class="o">=</span> <span class="n">DefaultTrafficSelector</span><span class="o">.</span><span class="n">builder</span><span class="p">(</span><span class="n">originalSelector</span><span class="p">)</span>
            <span class="o">.</span><span class="n">matchInPort</span><span class="p">(</span><span class="n">ingress</span><span class="o">.</span><span class="n">port</span><span class="p">())</span>
            <span class="o">.</span><span class="n">build</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Optionally</span> <span class="n">apply</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">treatment</span>
    <span class="n">TrafficTreatment</span><span class="o">.</span><span class="n">Builder</span> <span class="n">treatmentBuilder</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">applyTreatment</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">treatmentBuilder</span> <span class="o">=</span> <span class="n">DefaultTrafficTreatment</span><span class="o">.</span><span class="n">builder</span><span class="p">(</span><span class="n">originalTreatment</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">treatmentBuilder</span> <span class="o">=</span> <span class="n">DefaultTrafficTreatment</span><span class="o">.</span><span class="n">builder</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">objectives</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">DefaultNextObjective</span><span class="o">.</span><span class="n">builder</span><span class="p">()</span>
            <span class="o">.</span><span class="n">withId</span><span class="p">(</span><span class="n">flowObjectiveService</span><span class="o">.</span><span class="n">allocateNextId</span><span class="p">())</span>
            <span class="o">.</span><span class="n">addTreatment</span><span class="p">(</span><span class="n">treatmentBuilder</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">egress</span><span class="o">.</span><span class="n">port</span><span class="p">())</span><span class="o">.</span><span class="n">build</span><span class="p">())</span>
            <span class="o">.</span><span class="n">withType</span><span class="p">(</span><span class="n">NextObjective</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">SIMPLE</span><span class="p">)</span>
            <span class="o">.</span><span class="n">fromApp</span><span class="p">(</span><span class="n">appId</span><span class="p">)</span>
            <span class="o">.</span><span class="n">makePermanent</span><span class="p">()</span>
            <span class="o">.</span><span class="n">add</span><span class="p">());</span>
    <span class="n">devices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ingress</span><span class="o">.</span><span class="n">deviceId</span><span class="p">());</span>

    <span class="n">objectives</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">DefaultForwardingObjective</span><span class="o">.</span><span class="n">builder</span><span class="p">()</span>
            <span class="o">.</span><span class="n">withSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
            <span class="o">.</span><span class="n">nextStep</span><span class="p">(</span><span class="n">nextObjective</span><span class="o">.</span><span class="n">id</span><span class="p">())</span>
            <span class="o">.</span><span class="n">withPriority</span><span class="p">(</span><span class="n">priority</span><span class="p">)</span>
            <span class="o">.</span><span class="n">fromApp</span><span class="p">(</span><span class="n">appId</span><span class="p">)</span>
            <span class="o">.</span><span class="n">makePermanent</span><span class="p">()</span>
            <span class="o">.</span><span class="n">withFlag</span><span class="p">(</span><span class="n">ForwardingObjective</span><span class="o">.</span><span class="n">Flag</span><span class="o">.</span><span class="n">SPECIFIC</span><span class="p">)</span>
            <span class="o">.</span><span class="n">add</span><span class="p">());</span>
    <span class="n">devices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ingress</span><span class="o">.</span><span class="n">deviceId</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above example creates a Next objective and a Forwarding objective,
with the Next objective applying a Treatment to the flow. Minimally,
that Treatment sets the output port, but optionally, it also applies
the <code class="docutils literal notranslate"><span class="pre">originalTreatment</span></code> passed in as an argument to <code class="docutils literal notranslate"><span class="pre">createFlow</span></code>.</p>
</div>
<div class="section" id="southbound-interface">
<h2>6.4 Southbound Interface<a class="headerlink" href="#southbound-interface" title="Permalink to this headline">¶</a></h2>
<p>A critical part of ONOS’s flexibility is its ability to accommodate
different control protocols. While the nature of control interactions
and associated abstractions was certainly inspired by the OpenFlow
protocol, ONOS is designed to ensure that the core (and the
applications written on top of the core) are insulated from the
specifics of the control protocol.</p>
<p>This section takes a closer look at how the ONOS accommodates multiple
protocols and heterogeneous network devices. The basic approach is
based on a plugin architecture, with two types of plugins: <em>Protocol
Providers</em> and <em>Device Drivers</em>. The following subsections describe
each, in turn.</p>
<div class="section" id="provider-plugins">
<h3>6.4.1 Provider Plugins<a class="headerlink" href="#provider-plugins" title="Permalink to this headline">¶</a></h3>
<p>ONOS defines a Southbound Interface (SBI) plugin framework, where each
plugin defines some southbound (network facing) API. Each plugin,
called a <em>Protocol Provider</em>, serves as a proxy between the SBI and
the underlying network, where there is no limitation of what control
protocol each can use to communicate with the network. Providers
register themselves with the SBI plugin framework, and can start
acting as a conduit for passing information and control directives
between ONOS applications and core services (above) and the network
environment (below), as illustrated in <a class="reference internal" href="#fig-plugins"><span class="std std-numref">Figure 34</span></a>.</p>
<div class="figure align-center" id="id12">
<span id="fig-plugins"></span><a class="reference internal image-reference" href="_images/Slide35.png"><img alt="_images/Slide35.png" src="_images/Slide35.png" style="width: 550px;" /></a>
<p class="caption"><span class="caption-number">Figure 34. </span><span class="caption-text">ONOS Southbound Interface (SBI) is extended by Provider Plugins.</span></p>
</div>
<p><a class="reference internal" href="#fig-plugins"><span class="std std-numref">Figure 34</span></a> includes two general kinds of
Provider plugins. The first type are protocol-specific, with OpenFlow
and gNMI being typical examples. Each of these Providers effectively
bundles the API with the code that implements the corresponding
protocol. The second type—of which <em>DeviceProvider</em>, <em>HostProvider</em>,
and <em>LinkProvider</em> are the examples shown in the figure—interact
indirectly with the environment using some other ONOS service. We saw
an example of this in Section 6.2.2, where Host Location Provider (an
ONOS service) sits behind <em>HostProvider</em> (an SBI plugin); the latter
defines the API for host discovery and the former defines one specific
approach to discovering hosts (e.g., using Packet Service to intercept
ARP, NDP and DHCP packets). Similarly, Lldp Link Provider
(corresponding to the <em>LinkProvider</em> SBI plugin) uses Packet Service
to intercept LLDP and BDDP packets to surmise links between
infrastructure devices.</p>
</div>
<div class="section" id="device-drivers">
<h3>6.4.2 Device Drivers<a class="headerlink" href="#device-drivers" title="Permalink to this headline">¶</a></h3>
<p>In addition to insulating the core from protocol specifics, the SBI
framework also supports Device Drivers plugins as a mechanism to
insulate code (including Providers) from device-specific variations. A
Device Driver is a collection of modules, each of which implements a
very narrow facet of control or configuration capabilities. As with
the Protocol Providers, no limitations are placed on how the device
driver chooses to implement those capabilities. Device drivers are
also deployed as ONOS applications, which allows them to be installed
and uninstalled dynamically allowing operators to introduce new device
types and models on the fly.</p>
</div>
</div>
<div class="section" id="scalable-performance">
<h2>6.5 Scalable Performance<a class="headerlink" href="#scalable-performance" title="Permalink to this headline">¶</a></h2>
<p>ONOS is a logically centralized SDN controller, and as such, must
ensure that it is able to respond to a scalable number of control
events in a timely way. It must also remain available in the face of
failures. This section describes how ONOS scales to meet these
performance and availability requirements. But first the numbers,
where ONOS represents the state-of-the-art in centralized network
control:</p>
<ul class="simple">
<li><strong>Scale:</strong> ONOS supports up to 50 network devices; 5000 network
ports; 50k subscribers, 1M routes; and 5M flow rules/groups/meters.</li>
<li><strong>Performance:</strong> ONOS supports up to 10k configuration ops/day; 500k
flow ops/sec (sustained); 1k topology events/sec (peak); 50ms to
detect port/switch up events; 5ms to detect port/switch down events;
3ms for flow ops; and 6ms for hand-over events (RAN).</li>
</ul>
<p>Production deployments run at least three instances of ONOS, but this
is more for availability than performance. Each instance runs on a
32-Core/128GB-RAM server, and is deployed as a Docker container using
Kubernetes. Each instance bundles an identical (but configurable)
collection of core services, control applications, and protocol
providers, where ONOS uses Karaf as its internal modularity framework.
The bundle also includes Atomix, although ONOS supports an optional
configuration that scales the key/value store independently from the
rest of ONOS.</p>
<div class="figure align-center" id="id13">
<span id="fig-ha"></span><a class="reference internal image-reference" href="_images/Slide42.png"><img alt="_images/Slide42.png" src="_images/Slide42.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Figure 35. </span><span class="caption-text">Multiple ONOS instances, all sharing network state via Atomix,
provides scalable performance and high availability.</span></p>
</div>
<p><a class="reference internal" href="#fig-ha"><span class="std std-numref">Figure 35</span></a> illustrates ONOS scaling across multiple
instances, where the set of instances share network state via Atomix
Maps. The figure also shows each instance being responsible for a
subset of the underlying hardware switches. Should a given instance
fail, the remaining instances use the Atomix leader-election primitive
to select a new instance to take its place, thereby ensuring high
availability.</p>
<p>A refactoring of ONOS to more closely adhere to a microservice
architecture is also underway. The new version, called µONOS,
leverages ONOS’s existing modularity, but packages and scales
different subsystems independently. Although in principle each of of
the core services introduced in this chapter could be packaged as an
independent microservice, doing so is much too fine-grain to be
practical. Instead, µONOS adopts the following approach. First, it
encapsulates Atomix in its own microservice. Second, it runs each each
control application and southbound adaptor as a separate
microservice. Third, it partitions the core into four distinct
microservices: (1) a <em>Topology Management</em> microservice that exports a
Network Graph API; (2) a <em>Control Management</em> microservice that
exports a P4Runtime API; (3) a <em>Configuration Management</em> microservice
that exports a gNMI API; and (4) an <em>Operations Management</em>
microservice that exports a gNOI API.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="trellis.html" class="btn btn-neutral float-right" title="Chapter 7: Leaf-Spine Fabric" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="stratum.html" class="btn btn-neutral float-left" title="Chapter 5: Switch OS" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
